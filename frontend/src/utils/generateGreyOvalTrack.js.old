// File: api/utils/generateGreyOvalTrack.ts
// Version: v0.6.0 â€” Parametric race track with true rounded corners and consistent offsets

import { Point } from '../types';

const STRAIGHT_SEGMENT_STEP_PX = 10;
const CORNER_SEGMENT_STEP_DEG = 2.5;
const TRACK_WIDTH = 120;
const CORNER_RADIUS = 500;
const START_LINE_OFFSET_PX = 30;

export function generateGreyOvalTrack(
  dimensions: { width: number; height: number },
  startAtPercent: number
): {
  innerBounds: { pointsArray: Point[] };
  outerBounds: { pointsArray: Point[] };
  centerline: Point[];
  startAt: Point;
  startLineAt: Point;
  startInnerPoint: Point;
  startOuterPoint: Point;
} {
  const { width, height } = dimensions;

  const paddingX = width * 0.05;
  const paddingY = height * 0.05;

  const outerW = width - 2 * paddingX;
  const outerH = height - 2 * paddingY;

  const outer = generateParametricOvalTrack(paddingX, paddingY, outerW, outerH, CORNER_RADIUS);
  const inner = generateParametricOvalTrack(
    paddingX + TRACK_WIDTH,
    paddingY + TRACK_WIDTH,
    outerW - 2 * TRACK_WIDTH,
    outerH - 2 * TRACK_WIDTH,
    CORNER_RADIUS
  );

  const centerline: Point[] = [];
  for (let i = 0; i < Math.min(inner.length, outer.length); i++) {
    centerline.push({
      x: (inner[i].x + outer[i].x) / 2,
      y: (inner[i].y + outer[i].y) / 2
    });
  }

  const startIndex = Math.floor(centerline.length * startAtPercent);
  const startAt = centerline[startIndex];
  const next = centerline[(startIndex + 1) % centerline.length];

  const dx = next.x - startAt.x;
  const dy = next.y - startAt.y;
  const len = Math.sqrt(dx * dx + dy * dy);
  const unitX = dx / len;
  const unitY = dy / len;

  const startLineAt = {
    x: startAt.x + unitX * START_LINE_OFFSET_PX,
    y: startAt.y + unitY * START_LINE_OFFSET_PX
  };

  return {
    innerBounds: { pointsArray: inner },
    outerBounds: { pointsArray: outer },
    centerline,
    startAt,
    startLineAt,
    startInnerPoint: inner[startIndex],
    startOuterPoint: outer[startIndex]
  };
}

function generateParametricOvalTrack(
  x: number,
  y: number,
  w: number,
  h: number,
  r: number
): Point[] {
  const points: Point[] = [];

  // Top straight
  addStraight(points, x + r, y, x + w - r, y);
  addArc(points, x + w - r, y + r, r, 270, 360); // Top-right
  addStraight(points, x + w, y + r, x + w, y + h - r); // Right
  addArc(points, x + w - r, y + h - r, r, 0, 90); // Bottom-right
  addStraight(points, x + w - r, y + h, x + r, y + h); // Bottom
  addArc(points, x + r, y + h - r, r, 90, 180); // Bottom-left
  addStraight(points, x, y + h - r, x, y + r); // Left
  addArc(points, x + r, y + r, r, 180, 270); // Top-left

  return points;
}

function addStraight(points: Point[], x1: number, y1: number, x2: number, y2: number) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const steps = Math.max(1, Math.ceil(dist / STRAIGHT_SEGMENT_STEP_PX));
  for (let i = 0; i <= steps; i++) {
    points.push({ x: x1 + (dx * i) / steps, y: y1 + (dy * i) / steps });
  }
}

function addArc(points: Point[], cx: number, cy: number, r: number, startDeg: number, endDeg: number) {
  for (let deg = startDeg; deg <= endDeg; deg += CORNER_SEGMENT_STEP_DEG) {
    const rad = (deg * Math.PI) / 180;
    points.push({ x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) });
  }
}
