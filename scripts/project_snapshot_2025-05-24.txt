📦 Generating full source snapshot for kd_race_app
Timestamp: Sat May 24 04:38:31 PM CDT 2025
Root: /docker/stacks/kd_race_app
==================================================


==== FILE: api/Dockerfile ====

# File: api/Dockerfile
# Version: v0.8.0 – Add TypeScript and tsx runtime support

FROM node:20

# Set working directory
WORKDIR /app

# Install dependencies (includes tsx for TypeScript runtime)
COPY ./package*.json ./
RUN npm install

# Copy all source files and Prisma schema
COPY . .
COPY ./prisma ./prisma

# Generate Prisma client
RUN npx prisma generate --schema=./prisma/schema.prisma

# Expose API port
EXPOSE 4000

# Run with tsx so we can execute TypeScript files directly
CMD ["npx", "tsx", "index.ts"]


==== FILE: api/index.ts ====

// File: api/index.ts
// Version: v0.8.3 — Mounts user, register, and betting routes properly

import express from "express";
import dotenv from "dotenv";
import { createServer } from "http";
import { Server } from "socket.io";
import cors from "cors";
import horsesRoute from "./routes/horses.js";
import registerRoute from "./routes/register.js";
import userRoute from "./routes/user.js";
import betRoute from "./routes/bet.js";
import { createAdminRoute } from "./routes/admin.js";
import replayRoute from "./routes/replay.js";
import trackRoute from "./routes/track.js";
import { setupRaceNamespace } from "./sockets/race.js";
import { execSync } from "child_process";

dotenv.config();

if (process.env.NODE_ENV !== "production") {
  try {
    console.log("🛠️ Running prisma generate...");
    execSync("npx prisma generate", { stdio: "inherit" });
  } catch (err) {
    console.error("❌ Prisma generate failed:", err);
  }
}

const app = express();
const server = createServer(app);

const io = new Server(server, {
  cors: { origin: "*" },
  path: "/api/socket.io"
});

app.use(cors());
app.use(express.json());

app.use((req, res, next) => {
  if (req.url.startsWith("/api/socket.io")) return next();
  next();
});

// 🔗 Mount REST API routes
app.use("/api/horses", horsesRoute);
app.use("/api/register", registerRoute);
app.use("/api/user", userRoute);              // ✅ NEW: fetch user & balance
app.use("/api/admin", createAdminRoute(io));
app.use("/api", replayRoute);
app.use("/api/track", trackRoute);
app.use("/api/bet", betRoute);

setupRaceNamespace(io);

const PORT = process.env.PORT || 4000;
server.listen(PORT, () => {
  console.log(`🔥 KD API running at http://localhost:${PORT}`);
});


==== FILE: api/lib/prisma.ts ====

// File: api/lib/prisma.ts
// Version: v0.1.0 – Converted to TypeScript

import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default prisma;


==== FILE: api/package.json ====

{
  "name": "kd_api",
  "version": "1.1.1",
  "type": "module",
  "main": "index.ts",
  "scripts": {
    "start": "tsx index.ts",
    "dev": "tsx watch index.ts",
    "postinstall": "echo 'Skipping prisma generate during install'",
    "generate": "prisma generate",
    "migrate": "prisma migrate dev",
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0",
    "dotenv": "^16.5.0",
    "express": "^4.19.2",
    "pg": "^8.14.1",
    "seedrandom": "^3.0.5",
    "socket.io": "^4.7.2",
    "pako": "^2.1.0"
  },
  "devDependencies": {
    "tsx": "^4.8.0",
    "prisma": "^6.6.0",
    "typescript": "^5.4.2"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  }
}


==== FILE: api/prisma/seed.ts ====

// File: prisma/seed.ts
// Version: v0.6.7 — Seeds users with Lease Loons currency

import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

const VARIANTS = ['bay', 'chestnut', 'palomino', 'black'];

function getRandomVariant(): string {
  return VARIANTS[Math.floor(Math.random() * VARIANTS.length)];
}

async function main() {
  console.log('🧹 Clearing old data...');

  // Clear in correct FK order
  await prisma.replayFrame.deleteMany();
  await prisma.horsePath.deleteMany();
  await prisma.trackMeta.deleteMany();
  await prisma.result.deleteMany();
  await prisma.race.deleteMany();
  await prisma.registration.deleteMany();
  await prisma.bet.deleteMany();
  await prisma.user.deleteMany();
  await prisma.horse.deleteMany();

  console.log('🐎 Seeding horses...');

  const redHorse = await prisma.horse.create({
    data: {
      name: 'Leaseloon Lightning',
      color: 'red',
      variant: getRandomVariant()
    }
  });
  const blueHorse = await prisma.horse.create({
    data: {
      name: 'Commission Crusher',
      color: 'blue',
      variant: getRandomVariant()
    }
  });
  const greenHorse = await prisma.horse.create({
    data: {
      name: 'Slack Galloper',
      color: 'green',
      variant: getRandomVariant()
    }
  });

  await prisma.horse.createMany({
    data: [
      { name: 'Elevator Pitcher', color: 'yellow', variant: getRandomVariant() },
      { name: 'Tour Sheet Trotter', color: 'purple', variant: getRandomVariant() },
      { name: 'Amenity Stampeder', color: 'orange', variant: getRandomVariant() },
      { name: 'Broker Blitz', color: 'pink', variant: getRandomVariant() },
      { name: 'Hot Desk Rocket', color: 'gray', variant: getRandomVariant() },
      { name: 'Sublease Sprinter', color: 'teal', variant: getRandomVariant() },
      { name: 'Cap Rate Comet', color: 'navy', variant: getRandomVariant() },
      { name: 'Buildout Bandit', color: 'lime', variant: getRandomVariant() },
      { name: 'SpaceIQ Speedster', color: 'cyan', variant: getRandomVariant() },
      { name: 'CoreNet Cruiser', color: 'maroon', variant: getRandomVariant() },
      { name: 'Amenity Arms Racer', color: 'olive', variant: getRandomVariant() },
      { name: 'Lease-Up Lightning', color: 'beige', variant: getRandomVariant() },
      { name: 'JLL Jockey Jet', color: 'white', variant: getRandomVariant() },
      { name: 'Stack Plan Slammer', color: 'indigo', variant: getRandomVariant() },
      { name: 'Fitwel Flyer', color: 'aqua', variant: getRandomVariant() },
      { name: 'Wayfinding Wonder', color: 'tan', variant: getRandomVariant() },
      { name: 'Occupier Outlaw', color: 'charcoal', variant: getRandomVariant() },
      { name: 'PropTech Prancer', color: 'silver', variant: getRandomVariant() }
    ]
  });

  console.log('🙋‍♂️ Creating test users with Lease Loons...');

  const colin = await prisma.user.create({
    data: {
      firstName: 'Colin',
      lastName: 'DiBiase',
      nickname: 'CD',
      deviceId: 'device_cd',
      currency: 1000 // 🪙 Lease Loons
    }
  });
  const jamie = await prisma.user.create({
    data: {
      firstName: 'Jamie',
      lastName: 'Leasewell',
      nickname: 'JL',
      deviceId: 'device_jl',
      currency: 1000
    }
  });
  const riley = await prisma.user.create({
    data: {
      firstName: 'Riley',
      lastName: 'Spacefinder',
      nickname: 'RS',
      deviceId: 'device_rs',
      currency: 1000
    }
  });

  console.log('📝 Registering users to horses...');

  await prisma.registration.createMany({
    data: [
      { userId: colin.id, horseId: redHorse.id },
      { userId: jamie.id, horseId: blueHorse.id },
      { userId: riley.id, horseId: greenHorse.id }
    ]
  });

  console.log('🏁 Creating race (empty stub for now)...');

  await prisma.race.create({
    data: {}
  });

  console.log('✅ Seed complete');
}

main()
  .catch((e) => {
    console.error('❌ Error seeding database:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


==== FILE: api/routes/admin.ts ====

// File: api/routes/admin.ts
// Version: v0.7.32 — Validated for WebSocket emit and track/horse layout

import express, { Request, Response } from "express";
import { Server } from "socket.io";
import prisma from "../lib/prisma.js";
import pako from "pako";
import { generateGreyOvalTrack } from "../utils/generateGreyOvalTrack";
import { computeTrackGeometry } from "../utils/computeTrackGeometry";
import { generateHorsePathWithSpeed } from "../utils/generateHorsePathWithSpeed";

const START_LINE_OFFSET_PX = 10;

function getTimestamp() {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/Chicago",
    month: "2-digit",
    day: "2-digit",
    year: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: true
  });
  const parts = formatter.formatToParts(now).reduce((acc, part) => {
    acc[part.type] = part.value;
    return acc;
  }, {} as Record<string, string>);
  return `${parts.month}-${parts.day}_${parts.year}_${parts.hour.padStart(2, "0")}-${parts.minute}${parts.dayPeriod}`;
}

export function createAdminRoute(io: Server) {
  const router = express.Router();

  router.post("/start", express.json(), async (req: Request, res: Response) => {
    const timestamp = getTimestamp();
    console.log(`[${timestamp}] 🏁 KD Backend Race Logic Version: v0.7.32`);

    const pass = req.headers["x-admin-pass"];
    if (pass !== process.env.API_ADMIN_PASS) {
      console.warn(`[${timestamp}] ⛔ Invalid admin pass`);
      return res.status(401).json({ error: "Unauthorized" });
    }

    const { startAtPercent, width, height } = req.body;
    if (
      typeof startAtPercent !== "number" ||
      typeof width !== "number" ||
      typeof height !== "number" ||
      isNaN(startAtPercent) ||
      isNaN(width) ||
      isNaN(height)
    ) {
      console.warn(`[${timestamp}] ❌ Invalid POST body:`, req.body);
      return res.status(400).json({ error: "Missing or invalid track parameters" });
    }

    const clampedPercent = Math.min(Math.max(startAtPercent, 0), 1);
    const safeWidth = Math.max(width, 800);
    const safeHeight = Math.max(height, 400);

    try {
      const allHorses = await prisma.horse.findMany();
      const selected = allHorses.sort(() => 0.5 - Math.random()).slice(0, 4);
      const race = await prisma.race.create({ data: {} });

      const track = generateGreyOvalTrack({ width: safeWidth, height: safeHeight }, clampedPercent);

      const { rotatedInner, rotatedOuter, rotatedCenterline } = computeTrackGeometry(
        track.innerBounds.pointsArray,
        track.outerBounds.pointsArray,
        track.centerline,
        track.startAt
      );

      const dx = rotatedCenterline[1].x - rotatedCenterline[0].x;
      const dy = rotatedCenterline[1].y - rotatedCenterline[0].y;
      const startAngle = Math.atan2(dy, dx);

      const raceNamespace = io.of("/race");

      if (raceNamespace.sockets.size > 0) {
        const horses = selected.map((h, i) => {
          const placement = i + 1;
          const pathData = track.perPlacement[placement];

          const result = generateHorsePathWithSpeed({
            horseId: h.id.toString(),
            placement,
            totalHorses: selected.length,
            pathData
          });

          return {
            id: h.id.toString(),
            name: h.name,
            color: h.color,
            placement,
            ...result
          };
        });

        const payload = {
          raceId: race.id.toString(),
          centerline: rotatedCenterline,
          innerBoundary: rotatedInner,
          outerBoundary: rotatedOuter,
          startAt: track.startAt,
          startLineAt: track.startLineAt,
          startAngle,
          startLineOffsetPx: START_LINE_OFFSET_PX,
          horses
        };

        const compressed = pako.deflate(JSON.stringify(payload));
        const sizeBefore = Buffer.byteLength(JSON.stringify(payload)) / 1024;
        const sizeAfter = compressed.length / 1024;
        console.log(`[${timestamp}] 📦 Emitting race:init (before: ${sizeBefore.toFixed(2)} KB, after: ${sizeAfter.toFixed(2)} KB)`);

        raceNamespace.emit("race:init", compressed);
        setTimeout(() => {
          raceNamespace.emit("race:start");
          console.log(`[${timestamp}] 🏇 race:start event emitted to /race clients`);
        }, 500);
      } else {
        console.warn(`[${timestamp}] ⚠️ No clients connected to /race`);
      }

      res.json({ success: true, raceId: race.id.toString() });
    } catch (err) {
      console.error(`[${timestamp}] 💥 Error in /api/admin/start`, {
        body: req.body,
        error: err
      });
      res.status(500).json({ error: "Internal server error" });
    }
  });

  return router;
}


==== FILE: api/routes/bet.ts ====

// File: api/routes/bet.ts
// Version: v1.0.0 — Submit or update a bet for the active race

import express, { Request, Response } from "express";
import prisma from "../lib/prisma";

const router = express.Router();

// POST /api/bet
router.post("/", async (req: Request, res: Response) => {
  const { deviceId, horseId, amount } = req.body;

  if (!deviceId || !horseId || typeof amount !== "number" || amount <= 0) {
    return res.status(400).json({ error: "deviceId, horseId, and amount > 0 are required" });
  }

  try {
    const user = await prisma.user.findUnique({ where: { deviceId } });
    if (!user) return res.status(404).json({ error: "User not found" });

    const race = await prisma.race.findFirst({
      where: { locked: false },
      orderBy: { id: "desc" }
    });
    if (!race) return res.status(400).json({ error: "No active race available" });

    const existingBet = await prisma.bet.findUnique({
      where: {
        userId_raceId: {
          userId: user.id,
          raceId: race.id
        }
      }
    });

    const refund = existingBet?.amount || 0;
    const adjustedBalance = user.currency + refund;

    if (adjustedBalance < amount) {
      return res.status(400).json({ error: "Insufficient Lease Loons" });
    }

    // Upsert bet
    await prisma.bet.upsert({
      where: {
        userId_raceId: {
          userId: user.id,
          raceId: race.id
        }
      },
      update: { horseId, amount },
      create: {
        userId: user.id,
        raceId: race.id,
        horseId,
        amount
      }
    });

    // Update user balance
    await prisma.user.update({
      where: { id: user.id },
      data: { currency: adjustedBalance - amount }
    });

    res.json({ success: true, newBalance: adjustedBalance - amount });
  } catch (err) {
    console.error("Betting error:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

export default router;


==== FILE: api/routes/horses.ts ====

// File: api/routes/horses.ts
// Version: v0.2.0 – Convert to TypeScript and add types to Prisma call

import express, { Request, Response } from "express";
import prisma from "../lib/prisma";

const router = express.Router();

// GET /api/horses → List all horses
router.get("/", async (_req: Request, res: Response) => {
  try {
    const horses = await prisma.horse.findMany({
      orderBy: { id: "asc" },
    });
    res.json(horses);
  } catch (error) {
    console.error("❌ Error fetching horses:", error);
    res.status(500).json({ error: "Failed to fetch horses" });
  }
});

export default router;


==== FILE: api/routes/races.ts ====

// File: frontend/src/utils/playRace.js
// Version: v0.2.2 — Triggered by frontend Start Race button, not race:start socket

export function playRace({ app, horseSprites, horsePaths, labelSprites, finishedHorses, horses }) {
  // Stop any existing ticker first
  app.ticker.stop();
  app.ticker.removeAll();
  
  const ticker = (delta) => {
    horseSprites.forEach((sprite, id) => {
      const path = horsePaths[id];
      if (!path || path.length < 2 || finishedHorses.has(id)) return;

      sprite.__progress = (sprite.__progress ?? 0) + 0.002 * delta;

      if (sprite.__progress >= 1) {
        sprite.__progress = 1;
        finishedHorses.add(id);
        if (finishedHorses.size === horses.length) {
          console.log('[KD] 🏁 All horses finished!');
          const winner = horses.find(h => h.placement === 1);
          console.log(`[KD] 🏆 Winner: Horse ${winner.name} (ID: ${winner.id})`);
        }
        return;
      }

      const idx = Math.floor(sprite.__progress * path.length);
      const cappedIdx = Math.min(idx, path.length - 2);
      const next = path[cappedIdx + 1];
      const curr = path[cappedIdx];
      const lerpT = (sprite.__progress * path.length) - cappedIdx;
      const x = curr.x + (next.x - curr.x) * lerpT;
      const y = curr.y + (next.y - curr.y) * lerpT;
      sprite.position.set(x, y);
      sprite.rotation = Math.atan2(next.y - curr.y, next.x - curr.x);

      const label = labelSprites.get(id);
      if (label) label.position.set(x, y);
    });
  };

  app.ticker.add(ticker);
  app.ticker.start();
}


==== FILE: api/routes/register.ts ====

// File: api/routes/register.ts
// Version: v0.3.1 — Sets starting Lease Loons via configurable constant

import express, { Request, Response } from "express";
import prisma from "../lib/prisma";

const router = express.Router();

// 💰 Starting Lease Loons for all new users
const STARTING_CURRENCY = 1000;

router.post("/", async (req: Request, res: Response) => {
  const { firstName, lastName, nickname, horseId, deviceId } = req.body;

  if (!firstName || !lastName || !deviceId) {
    return res.status(400).json({
      error: "firstName, lastName, and deviceId are required",
    });
  }

  try {
    let user = await prisma.user.findUnique({
      where: { deviceId },
    });

    if (!user) {
      user = await prisma.user.create({
        data: {
          firstName,
          lastName,
          nickname: nickname || null,
          deviceId,
          currency: STARTING_CURRENCY
        },
      });

      // Optional: register to a horse if provided
      if (horseId) {
        await prisma.registration.create({
          data: {
            userId: user.id,
            horseId,
          },
        });
      }
    }

    res.json({
      id: user.id,
      firstName: user.firstName,
      lastName: user.lastName,
      nickname: user.nickname,
      currency: user.currency,
      deviceId: user.deviceId
    });
  } catch (err) {
    console.error("Registration error:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

export default router;


==== FILE: api/routes/replay.ts ====

// File: api/routes/replay.ts
// Version: v0.7.3 – Converted to TypeScript with typed responses

import express, { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";

const router = express.Router();
const prisma = new PrismaClient();

// GET /api/race/:raceId/replay — Returns all tick frames for a race
router.get("/race/:raceId/replay", async (req: Request, res: Response) => {
  const { raceId } = req.params;

  if (!raceId || isNaN(Number(raceId))) {
    return res.status(400).json({ error: "Invalid or missing raceId" });
  }

  try {
    const frames = await prisma.replayFrame.findMany({
      where: { raceId: BigInt(raceId) },
      select: {
        horseId: true,
        pct: true,
        timeMs: true
      },
      orderBy: { timeMs: "asc" }
    });

    res.json({ frames });
  } catch (err) {
    console.error("❌ [Replay] Failed to fetch frames:", err);
    res.status(500).json({ error: "Failed to fetch replay frames" });
  }
});

// GET /api/races — Returns metadata for available replays
router.get("/races", async (_req: Request, res: Response) => {
  try {
    const races = await prisma.race.findMany({
      orderBy: { startedAt: "desc" },
      select: {
        id: true,
        startedAt: true
      }
    });

    const formatted = races.map((r, idx) => {
      const date = new Date(r.startedAt);
      const name = `Race: ${races.length - idx} – ${date.toLocaleString("en-US", {
        month: "2-digit",
        day: "2-digit",
        year: "2-digit",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      })}`;
      return { raceId: r.id.toString(), name };
    });

    res.json(formatted);
  } catch (err) {
    console.error("❌ [Replay] Failed to fetch race list:", err);
    res.status(500).json({ error: "Failed to fetch races" });
  }
});

export default router;


==== FILE: api/routes/results.ts ====

// File: api/routes/results.ts
// Version: v0.1.0 – Converted to TypeScript for type safety

import express, { Request, Response } from "express";
import { pool } from "../db.js";

const router = express.Router();

// GET /api/race/:raceId/results → Fetch race result leaderboard
router.get("/:raceId/results", async (req: Request, res: Response) => {
  const raceId = parseInt(req.params.raceId, 10);

  if (isNaN(raceId)) {
    return res.status(400).json({ error: "Invalid race ID" });
  }

  try {
    const result = await pool.query(
      `SELECT r.position, r.time_ms, h.id AS horse_id, h.name, h.color
       FROM results r
       JOIN horses h ON r.horse_id = h.id
       WHERE r.race_id = $1
       ORDER BY r.position`,
      [raceId]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("❌ Error fetching race results:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

export default router;


==== FILE: api/routes/track.ts ====

// File: api/routes/track.ts
// Version: v0.1.9 — Fixes track response shape to match frontend expectations (flattened boundary arrays)

import express, { Request, Response } from 'express';
import { generateGreyOvalTrack } from '../utils/generateGreyOvalTrack';
import { computeTrackGeometry } from '../utils/computeTrackGeometry';
import { Point } from '../types';

const router = express.Router();

router.get('/', (req: Request, res: Response) => {
  const rawPercent = req.query.startAtPercent;
  const rawWidth = req.query.width;
  const rawHeight = req.query.height;

  if (rawPercent === undefined || isNaN(Number(rawPercent))) {
    return res.status(400).json({ error: 'Missing or invalid startAtPercent' });
  }
  if (rawWidth === undefined || isNaN(Number(rawWidth))) {
    return res.status(400).json({ error: 'Missing or invalid width' });
  }
  if (rawHeight === undefined || isNaN(Number(rawHeight))) {
    return res.status(400).json({ error: 'Missing or invalid height' });
  }

  const startAtPercent = Math.min(Math.max(Number(rawPercent), 0), 1);
  const width = Math.max(Number(rawWidth), 800);
  const height = Math.max(Number(rawHeight), 400);

  const track = generateGreyOvalTrack({ width, height }, startAtPercent);

  const {
    rotatedInner,
    rotatedOuter,
    rotatedCenterline
  } = computeTrackGeometry(
    track.innerBounds.pointsArray,
    track.outerBounds.pointsArray,
    track.centerline,
    track.startAt
  );

  res.json({
    innerBoundary: rotatedInner,
    outerBoundary: rotatedOuter,
    rotatedCenterline,
    startLineAt: track.startLineAt,
    startAt: track.startAt,
    centerline: track.centerline
  });
});

export default router;


==== FILE: api/routes/user.ts ====

// File: api/routes/user.ts
// Version: v1.0.0 — Returns user info and current bet

import express, { Request, Response } from "express";
import prisma from "../lib/prisma";

const router = express.Router();

router.get("/:deviceId", async (req: Request, res: Response) => {
  const { deviceId } = req.params;

  try {
    const user = await prisma.user.findUnique({
      where: { deviceId },
    });

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Find the most recent unlocked race
    const race = await prisma.race.findFirst({
      where: { locked: false },
      orderBy: { id: "desc" }
    });

    // If there's a race, look for a bet
    let bet = null;
    if (race) {
      bet = await prisma.bet.findUnique({
        where: {
          userId_raceId: {
            userId: user.id,
            raceId: race.id
          }
        },
        select: {
          raceId: true,
          horseId: true,
          amount: true
        }
      });
    }

    res.json({
      id: user.id,
      firstName: user.firstName,
      lastName: user.lastName,
      nickname: user.nickname,
      currency: user.currency,
      bet: bet || null
    });
  } catch (err) {
    console.error("User fetch error:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});

export default router;


==== FILE: api/sockets/race.ts ====

// File: api/sockets/race.ts
// Version: v0.9.1 – Fix TS import paths after migration

import seedrandom from "seedrandom";
import { Server, Socket } from "socket.io";
import { PrismaClient } from "@prisma/client";
import { generateRoundedRectCenterline } from "../utils/generateRoundedRectCenterline.ts";
import { generateHorsePathWithSpeed } from "../utils/generateHorsePathWithSpeed.ts";
import { Point } from "../types";

const prisma = new PrismaClient();

const DEBUG = true;
const debugLog = (...args: any[]) => DEBUG && console.log(...args);
const errorLog = (...args: any[]) => console.error("❌", ...args);

let currentTournamentSeed = Date.now();

export function setupRaceNamespace(io: Server): void {
  const raceNamespace = io.of("/race");

  raceNamespace.on("connection", (socket: Socket) => {
    debugLog("✅ [WS] Client connected to /race:", socket.id);

    socket.on("admin:setTournamentSeed", ({ seed }: { seed: number }) => {
      currentTournamentSeed = seed;
      debugLog("🌱 Tournament seed set to:", seed);
    });

    socket.on("startRace", async ({
      raceId,
      horses
    }: {
      raceId: string;
      horses: { id: number; name: string; color: string }[];
    }) => {
      debugLog(`🏁 [Race] startRace received – RaceID: ${raceId}`);
      debugLog("🐎 Horses:", horses);

      try {
        await prisma.race.create({
          data: {
            id: BigInt(raceId),
            startedAt: new Date()
          }
        });
        debugLog("💾 [DB] Race inserted");
      } catch (err) {
        errorLog("[DB] Failed to insert race:", err);
        return;
      }

      const rng = seedrandom(String(currentTournamentSeed));
      const innerBounds = { x: 200, y: 150, width: 600, height: 350 };
      const cornerRadius = 120;
      const centerline: Point[] = generateRoundedRectCenterline(
        innerBounds,
        cornerRadius,
        400
      );

      const horsePaths = generateHorsePathWithSpeed(centerline, {
        laneCount: horses.length,
        startAt: centerline[0],
        debug: true,
        debugOutputPath: `./replays/paths-race-${raceId}.json`
      });

      const horseStates: Record<number, number> = {};
      const startTime = Date.now();

      for (const horse of horses) {
        horseStates[horse.id] = 0;
      }

      raceNamespace.emit("race:init", {
        raceId,
        horses,
        horsePaths
      });
      debugLog("📤 [Race] race:init emitted with generated paths");

      const interval = setInterval(async () => {
        let allFinished = true;

        for (const horse of horses) {
          if (horseStates[horse.id] >= 100) continue;

          const delta = 1.2 + rng() * 2.2;
          horseStates[horse.id] += delta;

          const pct = Math.min(horseStates[horse.id], 100);
          const timeMs = Date.now() - startTime;

          try {
            await prisma.replayFrame.create({
              data: {
                raceId: BigInt(raceId),
                horseId: horse.id,
                pct,
                timeMs
              }
            });
          } catch (err) {
            errorLog("❌ [DB] Failed to store replay frame:", err);
          }

          raceNamespace.emit("race:tick", {
            raceId,
            horseId: horse.id,
            pct
          });
          debugLog(`↪️ [Tick] Horse ${horse.id} → ${pct.toFixed(1)}%`);

          if (pct < 100) allFinished = false;
        }

        if (allFinished) {
          clearInterval(interval);
          debugLog("🏁 [Race] All horses finished");

          const leaderboard = Object.entries(horseStates)
            .sort(([, a], [, b]) => b - a)
            .map(([horseId], index) => ({
              horseId: parseInt(horseId),
              position: index + 1,
              timeMs: 3000 + index * 250
            }));

          raceNamespace.emit("race:finish", leaderboard);
          debugLog("📤 [Race] race:finish emitted", leaderboard);

          try {
            await prisma.race.update({
              where: { id: BigInt(raceId) },
              data: { endedAt: new Date() }
            });

            for (const { horseId, position, timeMs } of leaderboard.slice(0, 3)) {
              await prisma.result.create({
                data: {
                  raceId: BigInt(raceId),
                  horseId,
                  position,
                  timeMs
                }
              });
              debugLog(
                `💾 [DB] Result saved: Horse ${horseId}, Pos ${position}, ${timeMs}ms`
              );
            }
          } catch (err) {
            errorLog("[DB] Error saving results:", err);
          }
        }
      }, 1000 / 30);
    });
  });
}


==== FILE: api/tsconfig.json ====

// File: api/tsconfig.json
// Version: v0.2.0 – Support full TypeScript migration across routes, sockets, and utils

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "allowJs": false,
    "checkJs": false,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*", "prisma/**/*", "types/**/*"],
  "exclude": ["node_modules", "dist"]
}


==== FILE: api/utils/calculateLaneFraction.ts ====

// File: shared/utils/calculateLaneFraction.ts
// Version: v0.1.0 — Calculates safe lane spacing between inner and outer bounds with padding

/**
 * Calculates a lane's fractional position between 0 (inner) and 1 (outer)
 * with optional padding to keep horses from hugging the edges.
 *
 * @param laneIndex Index of the horse (0-based)
 * @param total Total number of horses
 * @param paddingPercent How much padding to leave on each side (0.1 = 10%)
 */
export default function calculateLaneFraction(
    laneIndex: number,
    total: number,
    paddingPercent = 0.1
  ): number {
    if (total <= 1) return 0.5;
    const safeRange = 1 - paddingPercent * 2;
    const step = safeRange / (total - 1);
    return paddingPercent + laneIndex * step;
  }
  

==== FILE: api/utils/computeTrackGeometry.ts ====

// File: api/utils/computeTrackGeometry.ts
// Version: v0.4.0 — Rotates precomputed centerline + aligns all boundaries

import { Point } from '../types';

function rotate<T>(arr: T[], startIdx: number): T[] {
  return [...arr.slice(startIdx), ...arr.slice(0, startIdx)];
}

function closePath(path: Point[]): Point[] {
  const first = path[0];
  const last = path[path.length - 1];
  if (first.x !== last.x || first.y !== last.y) {
    return [...path, { ...first }];
  }
  return path;
}

function findClosestIndex(path: Point[], target: Point): number {
  let closestIndex = 0;
  let minDist = Infinity;
  for (let i = 0; i < path.length; i++) {
    const dx = path[i].x - target.x;
    const dy = path[i].y - target.y;
    const dist = dx * dx + dy * dy;
    if (dist < minDist) {
      minDist = dist;
      closestIndex = i;
    }
  }
  return closestIndex;
}

export function computeTrackGeometry(
  inner: Point[],
  outer: Point[],
  centerline: Point[],
  startAt: Point
): {
  rotatedInner: Point[];
  rotatedOuter: Point[];
  rotatedCenterline: Point[];
  startIndex: number;
} {
  if (!Array.isArray(inner) || !Array.isArray(outer) || !Array.isArray(centerline)) {
    throw new Error('computeTrackGeometry: Invalid inputs');
  }

  const minLength = Math.min(inner.length, outer.length, centerline.length);
  const slicedInner = inner.slice(0, minLength);
  const slicedOuter = outer.slice(0, minLength);
  const slicedCenterline = centerline.slice(0, minLength);

  const startIndex = findClosestIndex(slicedCenterline, startAt);
  const rotatedInner = closePath(rotate(slicedInner, startIndex));
  const rotatedOuter = closePath(rotate(slicedOuter, startIndex));
  const rotatedCenterline = closePath(rotate(slicedCenterline, startIndex));

  const rotatedStart = rotatedCenterline[0];
  const dx = rotatedStart.x - startAt.x;
  const dy = rotatedStart.y - startAt.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  console.log(`[KD] 🧭 computeTrackGeometry.ts (v0.4.0): startAt=(${startAt.x.toFixed(1)}, ${startAt.y.toFixed(1)})`);
  console.log(`[KD] 🔄 Rotated start = (${rotatedStart.x.toFixed(1)}, ${rotatedStart.y.toFixed(1)}), dist=${dist.toFixed(2)}`);

  return {
    rotatedInner,
    rotatedOuter,
    rotatedCenterline,
    startIndex
  };
}


==== FILE: api/utils/generateGreyOvalTrack.ts ====

// File: api/utils/generateGreyOvalTrack.ts
// Version: v0.9.4 — Aligns start positions with deduplicated centerline geometry

import { Point } from '../types';
import { generateOffsetLanes } from './generateOffsetLanes';

const SEGMENTS_PER_SIDE = 12;
const SEGMENTS_PER_CORNER = 12;
const TRACK_WIDTH = 120;
const OUTER_RADIUS = 100;
const INNER_RADIUS = 60;
const START_LINE_OFFSET_PX = 30;
const SPRITE_RADIUS = 12;
const SPACING_PX = 6;
const START_BEHIND_PX = 0;

const LANE_COUNT = 4;
const LANE_SPACING = 30;

export function generateGreyOvalTrack(
  dimensions: { width: number; height: number },
  startAtPercent: number
) {
  const { width, height } = dimensions;
  const paddingX = width * 0.05;
  const paddingY = height * 0.05;

  const outerX = paddingX;
  const outerY = paddingY;
  const outerW = width - 2 * paddingX;
  const outerH = height - 2 * paddingY;

  const innerX = outerX + TRACK_WIDTH;
  const innerY = outerY + TRACK_WIDTH;
  const innerW = outerW - 2 * TRACK_WIDTH;
  const innerH = outerH - 2 * TRACK_WIDTH;

  const outer = generateRoundedRectFixed(outerX, outerY, outerW, outerH, OUTER_RADIUS);
  const inner = generateRoundedRectFixed(innerX, innerY, innerW, innerH, INNER_RADIUS);

  const pointCount = Math.min(inner.length, outer.length);
  const innerAligned = inner.slice(0, pointCount);
  const outerAligned = outer.slice(0, pointCount);

  let centerline = [];
  for (let i = 0; i < pointCount; i++) {
    centerline.push({
      x: (innerAligned[i].x + outerAligned[i].x) / 2,
      y: (innerAligned[i].y + outerAligned[i].y) / 2
    });
  }

  if (centerline[0].x !== centerline.at(-1)?.x || centerline[0].y !== centerline.at(-1)?.y) {
    centerline.push({ ...centerline[0] });
  }

  // 🧼 Apply same deduplication logic as offset lanes
  const cleanedCenterline: Point[] = [centerline[0]];
  for (let i = 1; i < centerline.length; i++) {
    const prev = cleanedCenterline[cleanedCenterline.length - 1];
    const curr = centerline[i];
    const dist = Math.hypot(curr.x - prev.x, curr.y - prev.y);
    if (dist >= 1) {
      cleanedCenterline.push(curr);
    }
  }

  const startIndex = Math.floor(cleanedCenterline.length * startAtPercent);
  const startAt = cleanedCenterline[startIndex];
  const next = cleanedCenterline[(startIndex + 1) % cleanedCenterline.length];

  const dx = next.x - startAt.x;
  const dy = next.y - startAt.y;
  const len = Math.sqrt(dx * dx + dy * dy);
  const unitX = dx / len;
  const unitY = dy / len;

  const startLineAt: Point = {
    x: startAt.x + unitX * START_LINE_OFFSET_PX,
    y: startAt.y + unitY * START_LINE_OFFSET_PX
  };

  const laneOffsets = Array.from({ length: LANE_COUNT }, (_, i) => {
    const centerIndex = (LANE_COUNT - 1) / 2;
    return (i - centerIndex) * LANE_SPACING;
  }).reverse();

  const lanes = generateOffsetLanes(cleanedCenterline, laneOffsets);

  const perPlacement: Record<number, any> = {};
  for (let i = 0; i < lanes.length; i++) {
    const lane = lanes[i];
    const startPt = lane[startIndex];
    const behindStart: Point = {
      x: startPt.x - unitX * START_BEHIND_PX,
      y: startPt.y - unitY * START_BEHIND_PX
    };
    perPlacement[i + 1] = {
      startPoint: behindStart,
      path: lane,
      direction: { x: unitX, y: unitY }
    };
  }

  return {
    innerBounds: { pointsArray: innerAligned },
    outerBounds: { pointsArray: outerAligned },
    centerline: cleanedCenterline,
    lanes,
    perPlacement,
    startAt,
    startLineAt,
    startInnerPoint: innerAligned[startIndex],
    startOuterPoint: outerAligned[startIndex]
  };
}

function generateRoundedRectFixed(x: number, y: number, w: number, h: number, r: number): Point[] {
  const points: Point[] = [];

  addStraightFixed(points, x + r, y, x + w - r, y, SEGMENTS_PER_SIDE);
  addArcFixed(points, x + w - r, y + r, r, 270, 360, SEGMENTS_PER_CORNER);
  addStraightFixed(points, x + w, y + r, x + w, y + h - r, SEGMENTS_PER_SIDE);
  addArcFixed(points, x + w - r, y + h - r, r, 0, 90, SEGMENTS_PER_CORNER);
  addStraightFixed(points, x + w - r, y + h, x + r, y + h, SEGMENTS_PER_SIDE);
  addArcFixed(points, x + r, y + h - r, r, 90, 180, SEGMENTS_PER_CORNER);
  addStraightFixed(points, x, y + h - r, x, y + r, SEGMENTS_PER_SIDE);
  addArcFixed(points, x + r, y + r, r, 180, 270, SEGMENTS_PER_CORNER);

  return points;
}

function addStraightFixed(points: Point[], x1: number, y1: number, x2: number, y2: number, segments: number) {
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    points.push({
      x: x1 + (x2 - x1) * t,
      y: y1 + (y2 - y1) * t
    });
  }
}

function addArcFixed(points: Point[], cx: number, cy: number, r: number, startDeg: number, endDeg: number, segments: number) {
  const startRad = (startDeg * Math.PI) / 180;
  const endRad = (endDeg * Math.PI) / 180;
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const rad = startRad + (endRad - startRad) * t;
    points.push({
      x: cx + r * Math.cos(rad),
      y: cy + r * Math.sin(rad)
    });
  }
}


==== FILE: api/utils/generateHorsePathWithSpeed.ts ====

// File: backend/src/utils/generateHorsePathWithSpeed.ts
// Version: v1.4.0 — Cleaned: removes random curve-based speed distortion; frontend controls pacing

import { Point } from './types';
import { rotateTrackToStart } from './rotateTrack';
import { offsetLane } from './offsetLane';
import { computeSegmentLength } from './utils';
import { getPathLength } from './measurePath';

interface HorsePathOptions {
  horseId: string;
  placement: number;
  totalHorses: number;
  spriteRadius?: number;
  pathData: {
    startPoint: Point;
    path: Point[];
    direction: { x: number; y: number };
  };
}

const POST_FINISH_EXTRA_UNITS = 120;

export function generateHorsePathWithSpeed({
  horseId,
  placement,
  totalHorses,
  spriteRadius = 12,
  pathData
}: HorsePathOptions) {
  let { startPoint, path, direction } = pathData;

  if (!Array.isArray(path) || path.length < 2) {
    throw new Error('generateHorsePathWithSpeed: invalid precomputed path');
  }

  let closestIdx = 0;
  let minDist = Infinity;
  for (let i = 0; i < path.length; i++) {
    const dx = path[i].x - startPoint.x;
    const dy = path[i].y - startPoint.y;
    const dist = dx * dx + dy * dy;
    if (dist < minDist) {
      minDist = dist;
      closestIdx = i;
    }
  }

  const rotatedPath = [...path.slice(closestIdx), ...path.slice(0, closestIdx)];
  const rotatedStartPoint = rotatedPath[0];

  const dx = rotatedPath[1].x - rotatedPath[0].x;
  const dy = rotatedPath[1].y - rotatedPath[0].y;
  const len = Math.sqrt(dx * dx + dy * dy);
  const dirLaneX = dx / len;
  const dirLaneY = dy / len;
  const dot = dirLaneX * direction.x + dirLaneY * direction.y;

  const fullPath: Point[] = [];
  const speedMap: number[] = [];
  let finishIndex = -1;
  let postFinishUnits = 0;
  const totalPathPoints = rotatedPath.length;

  for (let i = 0; i < rotatedPath.length * 3; i++) {
    const curr = rotatedPath[i % rotatedPath.length];
    fullPath.push(curr);

    let speedFactor = 1;

    if (i >= totalPathPoints && (i % totalPathPoints) === 0 && finishIndex === -1) {
      finishIndex = fullPath.length - 1;
    }

    if (finishIndex === -1) {
      speedFactor = 1; // constant pacing — curve drama now controlled in playRace.js
    } else {
      postFinishUnits++;
      if (postFinishUnits < POST_FINISH_EXTRA_UNITS) {
        const fade = 1 - postFinishUnits / POST_FINISH_EXTRA_UNITS;
        speedFactor = fade;
      } else {
        speedFactor = 0;
        break;
      }
    }

    speedMap.push(speedFactor);
  }

  return {
    horseId,
    path: fullPath,
    speedMap,
    startPoint: rotatedStartPoint,
    direction,
    debug: {
      version: 'v1.4.0',
      horseId,
      placement,
      rotatedFrom: closestIdx,
      rotatedStartPoint,
      originalStartPoint: startPoint,
      dot,
      finishIndex
    },
    rotatedCenterline: rotatedPath
  };
}

==== FILE: api/utils/generateOffsetLanes.ts ====

// File: api/utils/generateOffsetLanes.ts
// Version: v0.4.8 — Adds guard for duplicate end points causing normal flip

import { Point } from '../types';

export function generateOffsetLanes(centerlineRaw: Point[], laneOffsets: number[]): Point[][] {
  if (centerlineRaw.length < 2) throw new Error('generateOffsetLanes: centerline too short');

  // 🧼 Step 1: Filter out duplicate or near-overlapping points
  const centerline: Point[] = [centerlineRaw[0]];
  for (let i = 1; i < centerlineRaw.length; i++) {
    const prev = centerline[centerline.length - 1];
    const curr = centerlineRaw[i];
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const dist = Math.hypot(dx, dy);
    if (dist >= 1) {
      centerline.push(curr);
    } else {
      console.warn(`[KD] ⚠️ Removed redundant centerline point at index ${i} (dist=${dist.toFixed(4)})`);
    }
  }

  // 🧼 Step 2: Prevent false loopback point duplicating the start (often causes flip)
  const first = centerline[0];
  const last = centerline[centerline.length - 1];
  if (Math.abs(first.x - last.x) < 1 && Math.abs(first.y - last.y) < 1) {
    centerline.pop();
    console.warn('[KD] 🧽 Removed final point matching first to avoid seam discontinuity');
  }

  const lanes: Point[][] = laneOffsets.map(() => []);
  let prevAngle: number | null = null;

  for (let i = 0; i < centerline.length; i++) {
    const prev = centerline[(i - 1 + centerline.length) % centerline.length];
    const next = centerline[(i + 1) % centerline.length];

    const dx1 = centerline[i].x - prev.x;
    const dy1 = centerline[i].y - prev.y;
    const dx2 = next.x - centerline[i].x;
    const dy2 = next.y - centerline[i].y;
    const avgDx = (dx1 + dx2) / 2;
    const avgDy = (dy1 + dy2) / 2;
    let angle = Math.atan2(avgDy, avgDx);

    // 🔁 Normalize angle continuity to prevent flipping
    if (prevAngle !== null) {
      while (angle - prevAngle > Math.PI) angle -= 2 * Math.PI;
      while (angle - prevAngle < -Math.PI) angle += 2 * Math.PI;
    }
    prevAngle = angle;

    const normalAngle = angle + Math.PI / 2;
    const normalX = Math.cos(normalAngle);
    const normalY = Math.sin(normalAngle);

    const curr = centerline[i];
    laneOffsets.forEach((offset, laneIndex) => {
      lanes[laneIndex].push({
        x: curr.x + normalX * offset,
        y: curr.y + normalY * offset,
      });
    });
  }

  // 🧵 Close each lane loop explicitly
  for (const lane of lanes) {
    const first = lane[0];
    const last = lane[lane.length - 1];
    if (first.x !== last.x || first.y !== last.y) {
      lane.push({ ...first });
    }
  }

  return lanes;
}


==== FILE: api/utils/generateRoundedRectCenterline.ts ====

// File: api/utils/generateRoundedRectCenterline.ts
// Version: v0.2.0 – Convert to TypeScript with types for bounds and output points

interface Point {
  x: number;
  y: number;
}

interface Bounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * Generate a discretized rounded rectangle path using bounds and corner radius.
 * Used for calculating central path between inner and outer track boundaries.
 *
 * @param bounds - { x, y, width, height } of the path rectangle
 * @param radius - corner radius
 * @param segments - total number of segments
 * @returns Array of points
 */
export function generateRoundedRectCenterline(
  bounds: Bounds,
  radius: number,
  segments: number = 400
): Point[] {
  const points: Point[] = [];
  const { x, y, width, height } = bounds;

  const straightH = width - 2 * radius;
  const straightV = height - 2 * radius;
  const arcSeg = Math.floor(segments / 4 / 2);
  const sideSeg = Math.floor(segments / 4);

  // Top-left corner (180° to 270°)
  for (let i = 0; i <= arcSeg; i++) {
    const theta = Math.PI + (Math.PI / 2) * (i / arcSeg);
    points.push({
      x: x + radius + radius * Math.cos(theta),
      y: y + radius + radius * Math.sin(theta)
    });
  }

  // Top horizontal
  for (let i = 1; i <= sideSeg; i++) {
    points.push({
      x: x + radius + (straightH * i) / sideSeg,
      y: y
    });
  }

  // Top-right corner (270° to 360°)
  for (let i = 0; i <= arcSeg; i++) {
    const theta = (3 * Math.PI) / 2 + (Math.PI / 2) * (i / arcSeg);
    points.push({
      x: x + width - radius + radius * Math.cos(theta),
      y: y + radius + radius * Math.sin(theta)
    });
  }

  // Right vertical
  for (let i = 1; i <= sideSeg; i++) {
    points.push({
      x: x + width,
      y: y + radius + (straightV * i) / sideSeg
    });
  }

  // Bottom-right corner (0° to 90°)
  for (let i = 0; i <= arcSeg; i++) {
    const theta = (Math.PI / 2) * (i / arcSeg);
    points.push({
      x: x + width - radius + radius * Math.cos(theta),
      y: y + height - radius + radius * Math.sin(theta)
    });
  }

  // Bottom horizontal
  for (let i = 1; i <= sideSeg; i++) {
    points.push({
      x: x + width - radius - (straightH * i) / sideSeg,
      y: y + height
    });
  }

  // Bottom-left corner (90° to 180°)
  for (let i = 0; i <= arcSeg; i++) {
    const theta = Math.PI / 2 + (Math.PI / 2) * (i / arcSeg);
    points.push({
      x: x + radius + radius * Math.cos(theta),
      y: y + height - radius + radius * Math.sin(theta)
    });
  }

  // Left vertical
  for (let i = 1; i <= sideSeg; i++) {
    points.push({
      x: x,
      y: y + height - radius - (straightV * i) / sideSeg
    });
  }

  return points;
}


==== FILE: docker-compose.yml ====

# File: docker-compose.yml
# Version: v0.7.39 – Restore builder flow using bind mount copy

services:
  # 🚀 Frontend build stage (for one-off use)
  kd_frontend:
    build:
      context: .  # 🔧 Full access from root
      dockerfile: frontend/Dockerfile
    volumes:
      - ./frontend_dist_temp:/app/frontend/dist:ro  # ✅ Temporary build output

  # 📦 Copy built frontend assets into final mount directory
  kd_copy_frontend:
    image: alpine
    depends_on:
      - kd_frontend
    volumes:
      - ./volumes/kd_race_app_dist_build:/target
      - ./frontend_dist_temp:/source:ro
    entrypoint: ["sh", "-c"]
    command: >
      echo '🔍 Copying dist files...' &&
      rm -rf /target/* &&
      cp -r /source/* /target/ &&
      echo '✅ Copy complete'

  # 🔧 Backend API
  kd_api:
    build:
      context: ./api
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
    volumes:
      - ./volumes/kd_race_app_dist_build:/app/public
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgres://derby_admin:${DB_PASS}@192.168.50.209:5432/derby
      - API_ADMIN_PASS=${API_ADMIN_PASS}
    restart: unless-stopped
    networks:
      - kd_net

  # 🌐 Nginx reverse proxy
  kd_nginx:
    image: nginx:alpine
    container_name: kd_race_app-kd_nginx-1
    ports:
      - "8086:80"
    volumes:
      - ./volumes/kd_race_app_dist_build:/usr/share/nginx/html:ro  # ✅ Bind mount for live preview
      - ./nginx/kd.conf:/etc/nginx/conf.d/default.conf:ro
    restart: unless-stopped
    networks:
      - kd_net

networks:
  kd_net:
    driver: bridge

==== FILE: .env ====

# KD Race App environment config
# This file is used by Docker Compose to inject secrets at build and runtime.

# 🔐 PostgreSQL password for derby_admin user
DB_PASS=3K!JXoRiP3ir@7yf

# 🔑 Admin password used to trigger /api/admin/start
API_ADMIN_PASS=6a2e8819c6fb4c15

# ✅ Prevent Prisma from trying to install client at runtime
PRISMA_GENERATE_SKIP_AUTOINSTALL=true

# 👤 Docker UID/GID for proper file ownership from kd_frontend_builder
PUID=1007
PGID=1003

# 📌 Note:
# DATABASE_URL is dynamically constructed in docker-compose.yml
# Format: postgres://derby_admin:${DB_PASS}@192.168.50.209:5432/derby


==== FILE: frontend/Dockerfile ====

# File: frontend/Dockerfile
# Version: v1.3.1 — Monorepo-aware Docker build using root pnpm-lock.yaml

FROM node:20-alpine AS builder
WORKDIR /app

# Install pnpm globally
RUN npm install -g pnpm

# Copy frontend package and monorepo lockfile
COPY frontend/package.json ./frontend/
COPY pnpm-lock.yaml ./pnpm-lock.yaml
COPY pnpm-workspace.yaml ./pnpm-workspace.yaml

# Install only frontend deps using workspace filter
RUN pnpm install --filter ./frontend...

# Copy full frontend source
COPY frontend ./frontend

# Build the frontend
WORKDIR /app/frontend
RUN pnpm run build

# Final stage: dist-only container
FROM alpine
WORKDIR /app
COPY --from=builder /app/frontend/dist /app/frontend/dist
CMD ["sh", "-c", "echo '✅ Frontend build complete. Serve /app/frontend/dist via Nginx or static host.' && sleep infinity"]


==== FILE: frontend/index.html ====

<!-- File: frontend/index.html -->
<!-- Version: v0.9.88 — Removes manual version injection; handled by Vite define -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KD Race App</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body class="bg-green-50 text-gray-900">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


==== FILE: frontend/package.json ====

{
  "type": "module",
  "name": "kd-frontend",
  "version": "1.0.5",
  "scripts": {
    "dev": "vite --host 0.0.0.0 --port 5173",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.6.8",
    "pixi.js": "^7.4.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.3",
    "seedrandom": "^3.0.5",
    "socket.io-client": "^4.7.2",
    "pako": "^2.1.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.3",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.24",
    "tailwindcss": "^3.3.2",
    "vite": "^5.2.9"
  }
}

==== FILE: frontend/src/App.jsx ====

// File: frontend/src/App.jsx
// Version: v0.5.0 — Uses RaceTrack.VERSION directly instead of global injection

import React from 'react';
import RaceTrack from './components/RaceTrack';

function App() {
  return (
    <div className="min-h-screen bg-green-50 p-4">
      <div className="relative">
        {/* Top-right version info */}
        <div className="absolute top-2 right-4 text-right text-xs">
          <div className="text-green-600">Loaded: {RaceTrack.VERSION}</div>
        </div>
        {/* App Title */}
      </div>

      {/* Race Track */}
      <RaceTrack />
    </div>
  );
}

export default App;


==== FILE: frontend/src/components/RaceTrack.jsx ====

// File: frontend/src/components/RaceTrack.jsx
// Version: v2.0.2 — Switches from getSpriteDimensions to measureSpriteSize using drawHorseSprite

import React, { useEffect, useRef, useState } from 'react';
import { Application } from 'pixi.js';
import { io } from 'socket.io-client';

import { drawDerbyTrack } from './track/drawTrack';
import { toggleDebugLayers } from './track/toggleDebugLayers';
import { triggerGenerateHorses } from './track/triggerGenerateHorses';
import { triggerStartRace } from './track/triggerStartRace';
import { initRaceListeners } from './track/initRaceListeners';
import ReplayControls from './ReplayControls';

import { getSpriteDimensions  } from '@/utils/spriteDimensionCache';

const VERSION = 'v2.0.2';
const socket = io('/race', { path: '/api/socket.io' });

const TRACK_WIDTH = window.innerWidth;
const TRACK_PADDING = 60;
const TRACK_HEIGHT = 700;
const CANVAS_HEIGHT = TRACK_HEIGHT + TRACK_PADDING * 2;

const CORNER_RADIUS = 200;
const LANE_COUNT = 4;
const HORSE_PADDING = 5;
const BOUNDARY_PADDING = 1;
const START_LINE_OFFSET = 100;

const SPEED_MULTIPLIER_DEFAULT = 1;

const RaceTrack = () => {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const appRef = useRef(null);

  const horseSpritesRef = useRef(new Map());
  const labelSpritesRef = useRef(new Map());
  const debugDotsRef = useRef([]);
  const debugPathLinesRef = useRef([]);
  const finishDotsRef = useRef([]);
  const startDotsRef = useRef([]);

  const trackDataRef = useRef(null);
  const horsePathsRef = useRef(new Map());
  const horsesRef = useRef([]);
  const finishedHorsesRef = useRef(new Set());
  const usedHorseIdsRef = useRef(new Set());

  const [debugVisible, setDebugVisible] = useState(false);
  const [raceReady, setRaceReady] = useState(false);
  const [canGenerate, setCanGenerate] = useState(true);
  const [speedMultiplier, setSpeedMultiplier] = useState(SPEED_MULTIPLIER_DEFAULT);
  const [replayHistory, setReplayHistory] = useState([]);
  const [replayToPlay, setReplayToPlay] = useState(null);

  useEffect(() => {
    const app = new Application({
      view: canvasRef.current,
      backgroundColor: 0xbaf0ba,
      width: containerRef.current.offsetWidth,
      height: CANVAS_HEIGHT,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true
    });
    app.stage.sortableChildren = true;
    app.start();
    appRef.current = app;

    fetch('/api/horses')
      .then(res => res.json())
      .then(async horses => {
        horsesRef.current = horses.slice(0, LANE_COUNT);

        const measuredWidths = await Promise.all(
          horsesRef.current.map(h =>
            getSpriteDimensions(h.hex, h.id, app, h.variant || 'bay').width
          )
        );
        const maxSpriteWidth = Math.max(...measuredWidths);
        const laneWidth = maxSpriteWidth + HORSE_PADDING;

        const track = drawDerbyTrack({
          app,
          width: TRACK_WIDTH,
          height: TRACK_HEIGHT,
          cornerRadius: CORNER_RADIUS,
          laneCount: LANE_COUNT,
          laneWidth,
          boundaryPadding: BOUNDARY_PADDING,
          trackPadding: TRACK_PADDING,
          startLineOffset: START_LINE_OFFSET,
          debug: debugVisible === true
        });

        if (!track || !track.lanes || !track.centerline) {
          console.error('[KD] ❌ drawDerbyTrack failed:', track);
          return;
        }

        trackDataRef.current = {
          ...track,
          laneCount: LANE_COUNT,
          laneWidth,
          spriteWidth: maxSpriteWidth
        };

        initRaceListeners({
          socket,
          appRef,
          horseSpritesRef,
          labelSpritesRef,
          debugDotsRef,
          debugPathLinesRef,
          finishDotsRef,
          startDotsRef,
          trackDataRef,
          horsePathsRef,
          horsesRef,
          finishedHorsesRef,
          usedHorseIdsRef,
          setRaceReady,
          setCanGenerate,
          debugVisible
        });
      });
  }, []);

  useEffect(() => {
    toggleDebugLayers({
      app: appRef.current,
      debugVisible,
      debugDotsRef,
      debugPathLinesRef,
      startDotsRef,
      finishDotsRef,
      labelSpritesRef
    });
  }, [debugVisible]);

  useEffect(() => {
    if (!replayToPlay || !appRef.current) return;

    import('../utils/playReplay').then(({ playReplay }) => {
      playReplay({
        app: appRef.current,
        horseSprites: horseSpritesRef.current,
        labelSprites: labelSpritesRef.current,
        horsePaths: horsePathsRef.current,
        replayData: replayToPlay.data
      });
    });
  }, [replayToPlay]);

  const handleGenerate = () => {
    const { lanes, centerline, spriteWidth } = trackDataRef.current ?? {};
    if (!lanes || !centerline || !spriteWidth) {
      console.error('[KD] ❌ trackDataRef is incomplete — cannot generate horses');
      return;
    }

    triggerGenerateHorses({
      app: appRef.current,
      trackData: {
        ...trackDataRef.current,
        lanes,
        centerline,
        spriteWidth
      },
      horsesRef,
      horseSpritesRef,
      labelSpritesRef,
      finishedHorsesRef,
      debugPathLinesRef,
      debugDotsRef,
      finishDotsRef,
      startDotsRef,
      horsePathsRef,
      width: TRACK_WIDTH,
      height: TRACK_HEIGHT,
      setRaceReady,
      setCanGenerate,
      usedHorseIdsRef,
      debugVisible
    });
  };

  const handleStartRace = () => {
    triggerStartRace({
      appRef,
      horsesRef,
      horsePathsRef,
      horseSpritesRef,
      labelSpritesRef,
      finishedHorsesRef,
      debugPathLinesRef,
      finishDotsRef,
      setRaceReady,
      setCanGenerate,
      speedMultiplier
    });

    if (typeof window !== 'undefined' && window.playRace) {
      window.playRace.onReplayReady = (replayData) => {
        setReplayHistory(prev => [...prev, {
          timestamp: Date.now(),
          data: replayData
        }]);
      };
    }
  };

  return (
    <div ref={containerRef} className="p-4 relative">
      <canvas
        ref={canvasRef}
        style={{ height: `${CANVAS_HEIGHT}px` }}
        className="block w-full"
      />
      <div className="mt-4 space-x-2">
        <button onClick={handleGenerate} disabled={!canGenerate} className="bg-blue-600 px-4 py-2 text-white rounded disabled:opacity-50">Generate Horses</button>
        <button onClick={handleStartRace} disabled={!raceReady} className="bg-green-600 px-4 py-2 text-white rounded disabled:opacity-50">Start Race</button>
        <button onClick={() => setDebugVisible(v => !v)} className="bg-gray-600 px-4 py-2 text-white rounded">Toggle Visuals</button>
        <button onClick={() => setSpeedMultiplier(speedMultiplier === SPEED_MULTIPLIER_DEFAULT ? 4 : SPEED_MULTIPLIER_DEFAULT)} className="bg-purple-600 px-4 py-2 text-white rounded">
          {speedMultiplier === SPEED_MULTIPLIER_DEFAULT ? 'Enable Test Speed' : 'Back to Live Speed'}
        </button>
      </div>
      <ReplayControls
        replays={replayHistory}
        onReplaySelect={(replay) => {
          console.log('[KD] 🎬 Playing saved replay', replay);
          setReplayToPlay(replay);
        }}
      />
    </div>
  );
};

RaceTrack.VERSION = VERSION;
export default RaceTrack;


==== FILE: frontend/src/components/ReplayControls.jsx ====

// File: frontend/src/components/ReplayControls.jsx
// Version: v0.1.2 — Fixes export to use default so RaceTrack can import cleanly

import React, { useState } from 'react';

export default function ReplayControls({ replays, onReplaySelect }) {
  const [expanded, setExpanded] = useState(false);

  const formatTimestamp = (ts) => {
    const date = new Date(ts);
    const options = {
      hour: 'numeric',
      minute: 'numeric',
      hour12: true
    };
    return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${date.toLocaleTimeString('en-US', options)}`;
  };

  return (
    <div className="absolute top-2 right-2 bg-white/80 backdrop-blur-sm p-2 rounded-xl shadow-md z-20">
      <button
        onClick={() => setExpanded(!expanded)}
        className="w-full px-3 py-1.5 bg-indigo-600 text-white text-sm rounded"
      >
        {expanded ? 'Hide Replays' : 'Show Replays'}
      </button>
      {expanded && (
        <ul className="mt-2 max-h-64 overflow-y-auto w-56">
          {replays.map((replay, index) => (
            <li
              key={replay.timestamp}
              className="border-b py-1 px-2 hover:bg-gray-100 cursor-pointer text-sm"
              onClick={() => onReplaySelect(replay)}
            >
              Race #{index + 1} — {formatTimestamp(replay.timestamp)}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}


==== FILE: frontend/src/components/track/debugConsole.js ====

// File: frontend/src/components/track/debugConsole.js
// Version: v0.1.1 — Adds logInfo alias for compatibility

let ENABLED = true;

export function setDebugLogging(enabled) {
  ENABLED = enabled;
  console.log(`[KD] 🛠 Debug logging ${enabled ? 'enabled' : 'disabled'}`);
}

export function log(...args) {
  if (ENABLED) {
    console.log('[KD]', ...args);
  }
}

export function warn(...args) {
  if (ENABLED) {
    console.warn('[KD]', ...args);
  }
}

export function error(...args) {
  if (ENABLED) {
    console.error('[KD]', ...args);
  }
}

export function info(...args) {
  if (ENABLED) {
    console.info('[KD]', ...args);
  }
}

// Alias for compatibility
export { info as logInfo };


==== FILE: frontend/src/components/track/drawTrack.js ====

// File: frontend/src/components/track/drawTrack.js
// Version: v2.1.1 — Fixes brown fill seam at 12 o’clock, full debug alignment

import { Graphics } from 'pixi.js';
import { generateCenterline } from '@/utils/generateTrackPathWithRoundedCorners';
import { generateAllLanes, generateOffsetLane } from '@/utils/generateOffsetLane';
import parseColorToHex from '@/utils/parseColorToHex';

export function drawDerbyTrack({
  app,
  width,
  height,
  cornerRadius,
  laneCount,
  laneWidth,
  boundaryPadding = 0,
  trackPadding = 0,
  debug = false,
  startLineOffset = 0,
  horses = [],
  debugDotsRef,
  debugPathLinesRef,
  labelSpritesRef
}) {
  const trackContainer = new Graphics();
  const totalLaneWidth = (laneWidth * laneCount) + 2 * boundaryPadding;
  const halfTrack = totalLaneWidth / 2;

  const centerline = generateCenterline({
    canvasWidth: width,
    canvasHeight: height + 2 * trackPadding,
    trackHeight: height,
    totalLaneWidth,
    cornerRadius,
    trackPadding
  });

  const { path, getPointAtDistance, getCurveFactorAt, length: pathLength } = centerline;

  if (!Array.isArray(path) || path.length < 2) {
    console.error('[KD] ❌ drawDerbyTrack: Invalid centerline path:', centerline);
    return null;
  }

  const expectedTop = {
    x: width / 2,
    y: trackPadding + cornerRadius
  };
  const dx = path[0].x - expectedTop.x;
  const dy = path[0].y - expectedTop.y;
  const delta = Math.sqrt(dx * dx + dy * dy);
  console.log(`[KD] 🎯 centerline[0]: (${path[0].x.toFixed(1)}, ${path[0].y.toFixed(1)}) vs expected (${expectedTop.x.toFixed(1)}, ${expectedTop.y.toFixed(1)}) → Δ=${delta.toFixed(2)}px`);

  const lanes = generateAllLanes(path, laneCount, laneWidth, boundaryPadding, path[0]);
  const inner = generateOffsetLane(path, -halfTrack, path[0]);
  const outer = generateOffsetLane(path, +halfTrack, path[0]);

  if (!lanes?.length || !inner?.length || !outer?.length) {
    console.error('[KD] ❌ Invalid offset lanes.');
    return null;
  }

  // 🧵 DEBUG: Check polygon closure delta
  const gapDx = outer[0].x - inner.at(-1).x;
  const gapDy = outer[0].y - inner.at(-1).y;
  const gapDelta = Math.sqrt(gapDx * gapDx + gapDy * gapDy);
  console.log(`[KD] 🔍 Fill seam gap Δ = ${gapDelta.toFixed(2)}px between outer[0] and inner[-1]`);

  // 🎨 Fill polygon — force close
  const fillOuter = [...outer, outer[0]];
  const fillInner = [...inner].reverse();
  fillInner.push(fillInner[0]); // force closure

  const fillPolygon = [
    ...fillOuter.flatMap(pt => [pt.x, pt.y]),
    ...fillInner.flatMap(pt => [pt.x, pt.y])
  ];

  trackContainer.beginFill(0xc49a6c);
  trackContainer.drawPolygon(fillPolygon);
  trackContainer.endFill();

  // 🧱 Border lines
  trackContainer.lineStyle(4, 0x888888);
  outer.forEach((pt, i) => i === 0 ? trackContainer.moveTo(pt.x, pt.y) : trackContainer.lineTo(pt.x, pt.y));
  trackContainer.lineTo(outer[0].x, outer[0].y);

  inner.forEach((pt, i) => i === 0 ? trackContainer.moveTo(pt.x, pt.y) : trackContainer.lineTo(pt.x, pt.y));
  trackContainer.lineTo(inner[0].x, inner[0].y);

  app.stage.addChild(trackContainer);

  // 🟢 Start line (green)
  const seg0 = path[0];
  const seg1 = path[1];
  const rotation = Math.atan2(seg1.y - seg0.y, seg1.x - seg0.x);
  const normal = { x: -Math.sin(rotation), y: Math.cos(rotation) };
  const halfLine = totalLaneWidth / 2;
  const startA = {
    x: seg0.x + normal.x * halfLine,
    y: seg0.y + normal.y * halfLine
  };
  const startB = {
    x: seg0.x - normal.x * halfLine,
    y: seg0.y - normal.y * halfLine
  };

  const startLine = new Graphics();
  startLine.lineStyle(4, 0x00ff00);
  startLine.moveTo(startA.x, startA.y);
  startLine.lineTo(startB.x, startB.y);
  startLine.zIndex = 100;
  app.stage.addChild(startLine);

  // 🔍 Debug overlays
  if (debug) {
    const centerlineGraphic = new Graphics();
    centerlineGraphic.lineStyle(1, 0x000000, 0.8);
    path.forEach((pt, i) => i === 0 ? centerlineGraphic.moveTo(pt.x, pt.y) : centerlineGraphic.lineTo(pt.x, pt.y));
    centerlineGraphic.lineTo(path[0].x, path[0].y);
    app.stage.addChild(centerlineGraphic);
    debugPathLinesRef.current.push(centerlineGraphic);

    const addDot = (x, y, color) => {
      const dot = new Graphics();
      dot.beginFill(color).drawCircle(0, 0, 5).endFill();
      dot.position.set(x, y);
      dot.zIndex = 101;
      app.stage.addChild(dot);
      debugDotsRef.current.push(dot);
    };

    addDot(path[0].x, path[0].y, 0x0000ff);
    addDot(expectedTop.x, expectedTop.y, 0xff0000);
    addDot(inner[0].x, inner[0].y, 0xff9900);
    addDot(outer[0].x, outer[0].y, 0xff9900);

    horses.slice(0, laneCount).forEach((horse, i) => {
      const lanePath = lanes[i];
      const colorHex = parseColorToHex(horse.color);
      const laneLine = new Graphics();
      laneLine.lineStyle(2, colorHex, 1);
      lanePath.forEach((pt, j) => j === 0 ? laneLine.moveTo(pt.x, pt.y) : laneLine.lineTo(pt.x, pt.y));
      app.stage.addChild(laneLine);
      debugPathLinesRef.current.push(laneLine);
    });
  }

  return {
    lanes,
    centerline,
    getPointAtDistance,
    getCurveFactorAt,
    pathLength
  };
}


==== FILE: frontend/src/components/track/initRaceListeners.js ====

// File: frontend/src/components/track/initRaceListeners.js
// Version: v1.1.1 — Sets horsesRef correctly to enable race start

import { inflate } from 'pako';
import { setupHorses } from './setupHorses';
import { logInfo } from './debugConsole';

export function initRaceListeners(options) {
  const {
    socket,
    appRef,
    horseSpritesRef,
    labelSpritesRef,
    debugDotsRef,
    debugPathLinesRef,
    finishDotsRef,
    startDotsRef,
    trackDataRef,
    horsePathsRef,
    horsesRef,
    finishedHorsesRef,
    usedHorseIdsRef,
    setRaceReady,
    setCanGenerate,
    debugVisible
  } = options;

  socket.on('race:init', (data) => {
    const inflated = inflate(new Uint8Array(data), { to: 'string' });
    const payload = JSON.parse(inflated);

    const app = appRef.current;
    if (app.__raceTicker) {
      logInfo('[KD] 🔁 Clearing old ticker before loading new horses');
      app.ticker.remove(app.__raceTicker);
      app.__raceTicker = null;
    }

    setupHorses({
      app,
      horses: payload.horses,
      debugVisible,
      horseSpritesRef,
      labelSpritesRef,
      debugDotsRef,
      debugPathLinesRef,
      finishDotsRef,
      startDotsRef,
      horsePathsRef,
      horsesRef,
      finishedHorsesRef
    });

    horsesRef.current = payload.horses; // ✅ Needed for triggerStartRace to work

    setRaceReady(true);
    setCanGenerate(false);
  });
}


==== FILE: frontend/src/components/track/setupHorses.js ====

// File: frontend/src/components/track/setupHorses.js
// Version: v1.7.1 — Passes `horse.variant` to enable coat coloring

import { Sprite, Text, TextStyle, Graphics } from 'pixi.js';
import { drawHorseSprite } from '@/utils/drawHorseSprite';
import parseColorToHex from '@/utils/parseColorToHex';

export function setupHorses({
  app,
  horses,
  horsePaths,
  horseSpritesRef,
  labelSpritesRef,
  finishedHorsesRef,
  debugPathLinesRef,
  debugDotsRef,
  finishDotsRef,
  startDotsRef,
  horsePathsRef,
  lanes,
  debugVisible = false
}) {
  console.log('[KD] 🧩 setupHorses CALLED');

  horseSpritesRef.current?.clear?.();
  labelSpritesRef.current?.clear?.();
  finishedHorsesRef.current?.clear?.();

  horseSpritesRef.current = new Map();
  labelSpritesRef.current = new Map();
  finishedHorsesRef.current = new Set();
  debugPathLinesRef.current = [];
  debugDotsRef.current = [];
  finishDotsRef.current = [];
  startDotsRef.current = [];
  horsePathsRef.current = horsePaths;

  horses.forEach((horse, index) => {
    const pathData = horsePaths.get(horse.id);
    if (!pathData || !Array.isArray(pathData.path) || pathData.path.length < 2) {
      console.warn(`[KD] ⚠️ Invalid path for horse ${horse.name}`);
      return;
    }

    const { getPointAtDistance, path } = pathData;
    const { x, y } = getPointAtDistance(0);

    const colorHex = parseColorToHex(horse.color);
    const sprite = drawHorseSprite(colorHex, app, horse.variant || 'bay');

    sprite.anchor.set(0.5);
    sprite.rotation = 0;
    sprite.x = x - sprite.width / 2;
    sprite.y = y;
    sprite.zIndex = 10;
    app.stage.addChild(sprite);
    horseSpritesRef.current.set(horse.id, sprite);

    console.log(`[KD] 🐎 Placing horse ${horse.name} | dbId=${horse.id} | localId=${horse.localId} → (${sprite.x.toFixed(1)}, ${sprite.y.toFixed(1)})`);

    const label = new Text(horse.name, new TextStyle({
      fill: '#000',
      fontSize: 12,
      fontWeight: 'bold',
      stroke: '#fff',
      strokeThickness: 2
    }));
    label.anchor.set(0.5);
    label.x = sprite.x;
    label.y = sprite.y - 20;
    label.zIndex = 11;
    labelSpritesRef.current.set(horse.id, label);
    if (debugVisible) app.stage.addChild(label);

    if (debugVisible) {
      const debugDot = new Graphics();
      debugDot.beginFill(colorHex).drawCircle(0, 0, 4).endFill();
      debugDot.position.set(sprite.x, sprite.y);
      debugDot.zIndex = 5;
      app.stage.addChild(debugDot);
      debugDotsRef.current.push(debugDot);
    }

    const line = new Graphics();
    line.lineStyle(1, colorHex, 0.6);
    path.forEach((pt, i) => {
      if (i === 0) line.moveTo(pt.x, pt.y);
      else line.lineTo(pt.x, pt.y);
    });
    line.zIndex = 1;
    debugPathLinesRef.current.push(line);
    if (debugVisible) app.stage.addChild(line);
  });
}


==== FILE: frontend/src/components/track/toggleDebugLayers.js ====

// File: frontend/src/components/track/toggleDebugLayers.js
// Version: v1.0.1 — Fixes destructuring bug

export function toggleDebugLayers({
  app,
  debugVisible,
  debugDotsRef,
  debugPathLinesRef,
  startDotsRef,
  finishDotsRef,
  labelSpritesRef
}) {
  const toggle = (items, visible) => {
    items.forEach(item => {
      if (visible && !app.stage.children.includes(item)) app.stage.addChild(item);
      else if (!visible && app.stage.children.includes(item)) app.stage.removeChild(item);
    });
  };

  toggle(debugDotsRef.current, debugVisible);
  toggle(debugPathLinesRef.current, debugVisible);
  toggle(startDotsRef.current, debugVisible);
  toggle(finishDotsRef.current, debugVisible);

  labelSpritesRef.current.forEach(label => {
    if (debugVisible && !app.stage.children.includes(label)) app.stage.addChild(label);
    else if (!debugVisible && app.stage.children.includes(label)) app.stage.removeChild(label);
  });
}


==== FILE: frontend/src/components/track/triggerGenerateHorses.js ====

// File: frontend/src/components/track/triggerGenerateHorses.js
// Version: v2.4.1 — Uses getSpriteDimensions (drawHorseSprite) to measure sprite width before generating horse paths

import { generateHorsePaths } from '@/utils/generateHorsePaths';
import { setupHorses } from './setupHorses';
import { logInfo } from './debugConsole';
import parseColorToHex from '@/utils/parseColorToHex';
import { getSpriteDimensions } from '@/utils/spriteDimensionCache';

export async function triggerGenerateHorses({
  app,
  trackData,
  horsesRef,
  horseSpritesRef,
  labelSpritesRef,
  finishedHorsesRef,
  debugPathLinesRef,
  debugDotsRef,
  finishDotsRef,
  startDotsRef,
  horsePathsRef,
  width,
  height,
  setRaceReady,
  setCanGenerate,
  usedHorseIdsRef,
  debugVisible
}) {
  console.log('[KD] 🟡 triggerGenerateHorses() START');

  try {
    if (!trackData || typeof trackData !== 'object') {
      console.error('[KD] ❌ trackData is missing or invalid:', trackData);
      return;
    }

    const { laneCount, lanes, centerline } = trackData;

    if (!Array.isArray(lanes) || lanes.length < laneCount) {
      console.error('[KD] ❌ Not enough valid lanes for horse generation');
      return;
    }

    const raceInitPayload = {
      startAtPercent: 0,
      width,
      height
    };

    console.log('[KD] 📨 POST /api/admin/start', raceInitPayload);

    try {
      await fetch('/api/admin/start', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-admin-pass': '6a2e8819c6fb4c15'
        },
        body: JSON.stringify(raceInitPayload)
      });
    } catch (err) {
      console.error('[KD] ❌ Error triggering race:', err);
      return;
    }

    let horses = [];
    try {
      const res = await fetch('/api/horses');
      const allHorses = await res.json();

      const usedSet = usedHorseIdsRef?.current || new Set();
      const unused = allHorses.filter(h => !usedSet.has(h.id));
      const selected = unused.slice(0, laneCount);

      horses = selected.map((h, index) => {
        const hex = parseColorToHex(h.color);
        const mapped = { ...h, localId: index, hex };
        logInfo(`[KD] 🎯 Assigning localId=${index} to horse id=${h.id}, name=${h.name}, hex=${hex.toString(16)}`);
        return mapped;
      });

      horsesRef.current = horses;
      if (usedHorseIdsRef?.current) {
        horses.forEach(h => usedHorseIdsRef.current.add(h.id));
      }

      horses.forEach(h =>
        logInfo(`[KD] 🐴 Selected Horse: ${h.name} | dbId=${h.id} | localId=${h.localId}`)
      );
    } catch (err) {
      console.error('[KD] ❌ Failed to fetch horses:', err);
      return;
    }

    if (!horses.length) {
      console.error('[KD] ❌ No horses available after filtering');
      return;
    }

    const { width: spriteWidth } = getSpriteDimensions(
      horses[0].hex,
      horses[0].id,
      app,
      horses[0].variant || 'bay'
    );

    const horsePaths = await generateHorsePaths({ horses, lanes, centerline, spriteWidth });

    if (!(horsePaths instanceof Map) || horsePaths.size === 0) {
      console.error('[KD] ❌ generateHorsePaths returned empty or invalid Map');
      return;
    }

    setupHorses({
      app,
      horses,
      horsePaths,
      horseSpritesRef,
      labelSpritesRef,
      finishedHorsesRef,
      debugPathLinesRef,
      debugDotsRef,
      finishDotsRef,
      startDotsRef,
      horsePathsRef,
      debugVisible
    });

    logInfo('[KD] ✅ Horses placed and rendered');
    setRaceReady(true);
    setCanGenerate(false);

    return horsePaths;

  } catch (fatal) {
    console.error('[KD] 💥 Uncaught error in triggerGenerateHorses:', fatal);
  }
}


==== FILE: frontend/src/components/track/triggerStartRace.js ====

// File: frontend/src/components/track/triggerStartRace.js
// Version: v1.1.3 — Logs passed speedMultiplier for verification

import { playRace } from '@/utils/playRace';

export function triggerStartRace({
  appRef,
  horsesRef,
  horsePathsRef,
  horseSpritesRef,
  labelSpritesRef,
  finishedHorsesRef,
  debugPathLinesRef,
  finishDotsRef,
  setRaceReady,
  setCanGenerate,
  speedMultiplier
}) {
  console.log('[KD] ▶️ triggerStartRace.js v1.1.3');

  const app = appRef.current;
  const horses = horsesRef.current;
  const horsePaths = horsePathsRef.current;

  if (!app || !horses?.length) {
    console.warn('[KD] ❌ No app or horses available to start race');
    return;
  }

  if (!(horsePaths instanceof Map)) {
    console.error('[KD] ❌ horsePathsRef must be a Map');
    return;
  }

  console.log('[KD] 🧪 Validating path data for horses (dbId, localId):');
  const missing = horses.filter(h => {
    const pathData = horsePaths.get(h.id);
    const valid = pathData?.path && pathData.path.length >= 2;
    console.log(`   ↪️ Horse ${h.name} | dbId=${h.id} | localId=${h.localId} | Path valid: ${!!valid}`);
    return !valid;
  });

  if (missing.length > 0) {
    console.warn('[KD] ⚠️ Some horses are missing path data — race not started.');
    missing.forEach(h => {
      console.warn(`[KD] ⚠️ Missing path for horse ${h.name} | dbId=${h.id} | localId=${h.localId}`);
    });
    return;
  }

  console.log('[KD] ✅ All horses have valid path data — preparing race');
  console.log('[KD] 🎯 speedMultiplier passed to playRace():', speedMultiplier);

  // 🔎 Deep trace logs for debugging ID mismatch issues
  console.log('[KD] 🔎 Final horse IDs in race:', horses.map(h => h.id));
  console.log('[KD] 🔎 horseSpritesRef keys:', Array.from(horseSpritesRef.current?.keys?.() ?? []));
  console.log('[KD] 🔎 horsePathsRef keys:', Array.from(horsePathsRef.current?.keys?.() ?? []));

  // 🧩 Identity check for ref Map objects
  console.log('[KD] 🧩 horseSpritesRef identity at race start:', horseSpritesRef.current);
  console.log('[KD] 🧩 horsePathsRef identity at race start:', horsePathsRef.current);

  setRaceReady(false);

  playRace({
    app,
    horseSprites: horseSpritesRef.current,
    horsePaths: horsePathsRef.current,
    labelSprites: labelSpritesRef.current,
    finishedHorses: finishedHorsesRef.current,
    horses: horsesRef.current,
    onRaceEnd: () => setCanGenerate(true),
    debugPathLinesRef,
    finishDotsRef,
    speedMultiplier
  });
}


==== FILE: frontend/src/index.css ====

/* 
 * File: frontend/src/index.css
 * Version: v1.0.0 — Tailwind setup for global styles
 * Applies base, component, and utility layers.
 */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add custom styles below if needed */


==== FILE: frontend/src/main.jsx ====

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


==== FILE: frontend/src/main-user.jsx ====

// File: frontend/src/main-user.jsx
// Version: v1.0.0 — Entry point for /users UI (register + dashboard)

import React from 'react';
import ReactDOM from 'react-dom/client';
import UsersApp from './pages/UserRegister.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <UsersApp />
  </React.StrictMode>
);


==== FILE: frontend/src/pages/UserRegister.jsx ====

// File: frontend/src/pages/UserRegister.jsx
// Version: v1.0.4 — Adds basename for correct subpath routing

import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import RegisterPage from './users/RegisterPage';
import DashboardPage from './users/DashboardPage';

function UsersApp() {
  return (
    <Router basename="/users">
      <Routes>
        <Route path="/" element={<RegisterPage />} />
        <Route path="/dashboard" element={<DashboardPage />} />
      </Routes>
    </Router>
  );
}

export default UsersApp;


==== FILE: frontend/src/pages/users/DashboardPage.jsx ====

// File: frontend/src/pages/users/DashboardPage.jsx
// Version: v1.1.0 — Mobile-friendly Derby-themed dashboard with JLL branding

import { useEffect, useState } from 'react';
import axios from 'axios';

export default function DashboardPage() {
  const [user, setUser] = useState(null);
  const deviceId = localStorage.getItem('deviceId');

  useEffect(() => {
    if (!deviceId) return;

    axios.get(`/api/user/${deviceId}`)
      .then(res => setUser(res.data))
      .catch(err => {
        console.error('Failed to fetch user:', err);
        setUser(null);
      });
  }, [deviceId]);

  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-white text-gray-600">
        Loading your dashboard...
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white px-4 py-6 flex flex-col items-center text-gray-900">
      <img src="/jll-logo.png" alt="JLL Logo" className="h-12 mb-4" />
      <h1 className="text-2xl font-serif font-bold text-red-700 mb-2">
        Welcome, {user.nickname}!
      </h1>

      <div className="bg-red-50 border border-red-200 rounded-xl shadow px-6 py-4 text-center w-full max-w-md space-y-4">
        <p className="text-lg">
          You have
          <span className="font-bold text-red-700 mx-2">
            {user.currency} Lease Loons
          </span>
        </p>

        <p className="text-sm text-gray-600">
          Hang tight — betting opens when the race starts.
        </p>
      </div>

      <div className="mt-8 w-full max-w-md text-center text-gray-500 text-sm">
        🐎 Watch for updates on your next race.
      </div>
    </div>
  );
}


==== FILE: frontend/src/pages/users/RegisterPage.jsx ====

// File: frontend/src/pages/users/RegisterPage.jsx
// Version: v1.4.0 — Responsive layout, bottom-left logo, redirect if registered, polished CTA

import { useEffect, useState } from 'react';
import axios from 'axios';

export default function RegisterPage() {
  const [form, setForm] = useState({
    firstName: '',
    lastName: '',
    nickname: ''
  });

  const [submitted, setSubmitted] = useState(false);
  const [checking, setChecking] = useState(true);

  // Generate or reuse device ID from localStorage
  const deviceId = localStorage.getItem('deviceId') || crypto.randomUUID();

  useEffect(() => {
    localStorage.setItem('deviceId', deviceId);

    // Check if already registered
    axios
      .get(`/api/register/check?deviceId=${deviceId}`)
      .then((res) => {
        if (res?.data?.registered) {
          window.location.href = '/users/dashboard';
        } else {
          setChecking(false);
        }
      })
      .catch((err) => {
        console.warn('Failed to check registration:', err);
        setChecking(false);
      });
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      await axios.post('/api/register', {
        ...form,
        deviceId
      });

      localStorage.setItem('deviceId', deviceId);
      setSubmitted(true);
    } catch (err) {
      alert('Registration failed');
      console.error(err);
    }
  };

  if (submitted) {
    window.location.href = '/users/dashboard';
    return null;
  }

  if (checking) {
    return (
      <div className="min-h-screen flex items-center justify-center text-gray-600">
        Checking registration...
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white px-4 py-8 flex flex-col items-center text-gray-800 relative">
      {/* Fixed logo in bottom-left corner */}
      <img
        src="/jll-logo.png"
        alt="JLL Logo"
        className="h-6 fixed bottom-4 left-4 opacity-80"
      />

      {/* Header */}
      <h1 className="text-3xl sm:text-4xl font-bold text-red-700 mb-2 text-center">
        🏁 Join the JLL Grand Gallop
      </h1>

      {/* Subtext */}
      <p className="text-gray-700 text-center mb-6 text-sm sm:text-base max-w-md">
        Register below to compete in our company race event.  
        You'll receive <strong>Lease Loons</strong> to place bets, and your nickname will show up on the leaderboard!
      </p>

      {/* Form */}
      <form
        onSubmit={handleSubmit}
        className="w-full max-w-md bg-white border border-gray-200 p-6 rounded-xl shadow space-y-4"
      >
        <input
          type="text"
          required
          placeholder="First Name"
          className="w-full border border-gray-300 px-4 py-3 rounded text-base placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-red-300"
          value={form.firstName}
          onChange={(e) => setForm({ ...form, firstName: e.target.value })}
        />
        <input
          type="text"
          required
          placeholder="Last Name"
          className="w-full border border-gray-300 px-4 py-3 rounded text-base placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-red-300"
          value={form.lastName}
          onChange={(e) => setForm({ ...form, lastName: e.target.value })}
        />
        <input
          type="text"
          required
          placeholder="Nickname (for leaderboard)"
          className="w-full border border-gray-300 px-4 py-3 rounded text-base placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-red-300"
          value={form.nickname}
          onChange={(e) => setForm({ ...form, nickname: e.target.value })}
        />
        <button
          type="submit"
          className="w-full bg-red-700 text-white font-semibold text-lg py-3 rounded-lg hover:bg-red-800 transition active:scale-95"
        >
          🎟️ Register Now
        </button>
      </form>
    </div>
  );
}


==== FILE: frontend/src/users.jsx ====

// File: frontend/src/users.jsx
// Version: v1.0.1 — Fixed default import path for users.html entrypoint

import React from 'react';
import ReactDOM from 'react-dom/client';
import UsersApp from './pages/UserRegister.jsx'; // ✅ Correct import
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <UsersApp />
  </React.StrictMode>
);


==== FILE: frontend/src/utils/arcUtils.js ====

// File: frontend/src/utils/arcUtils.js
// Version: v1.1.0 — Clamps arc distance; prevents invalid tangent; logs fallback cases

export function getPointAtDistance(path, distance) {
  if (!Array.isArray(path) || path.length < 2) return null;

  const totalLength = path.reduce((sum, p, i) => {
    if (i === 0) return 0;
    const dx = p.x - path[i - 1].x;
    const dy = p.y - path[i - 1].y;
    return sum + Math.sqrt(dx * dx + dy * dy);
  }, 0);

  let remaining = Math.max(0, Math.min(distance, totalLength));

  for (let i = 1; i < path.length; i++) {
    const p1 = path[i - 1];
    const p2 = path[i];
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const segLength = Math.sqrt(dx * dx + dy * dy);

    if (remaining <= segLength) {
      const t = segLength === 0 ? 0 : remaining / segLength;
      return {
        x: p1.x + dx * t,
        y: p1.y + dy * t
      };
    }
    remaining -= segLength;
  }

  return path[path.length - 1]; // fallback
}

export function getTangentAngle(path, distance) {
  if (!Array.isArray(path) || path.length < 2) return 0;

  const totalLength = path.reduce((sum, p, i) => {
    if (i === 0) return 0;
    const dx = p.x - path[i - 1].x;
    const dy = p.y - path[i - 1].y;
    return sum + Math.sqrt(dx * dx + dy * dy);
  }, 0);

  let remaining = Math.max(0, Math.min(distance, totalLength));

  for (let i = 1; i < path.length; i++) {
    const p1 = path[i - 1];
    const p2 = path[i];
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const segLength = Math.sqrt(dx * dx + dy * dy);

    if (remaining <= segLength) {
      return Math.atan2(dy, dx);
    }
    remaining -= segLength;
  }

  const last = path.at(-1);
  const prev = path.at(-2) || last;
  return Math.atan2(last.y - prev.y, last.x - prev.x);
}


==== FILE: frontend/src/utils/calculateFrontOffsetPoint.ts ====

// File: shared/utils/calculateFrontOffsetPoint.ts
// Version: v0.1.0 — Calculates offset point behind the start line using sprite width and track direction

import type { Point } from "@/types/geometry";

/**
 * Returns a point offset backward from the start line along the track direction vector.
 * Used to align the front tip of the horse sprite behind the start line.
 *
 * @param startPoint Where the horse's front should be
 * @param direction Normalized direction vector of the track at that point
 * @param spriteWidth Width of the horse sprite (used to estimate front offset)
 */
export default function calculateFrontOffsetPoint(
  startPoint: Point,
  direction: Point,
  spriteWidth: number
): Point {
  const offsetDistance = spriteWidth / 2;
  return {
    x: startPoint.x - direction.x * offsetDistance,
    y: startPoint.y - direction.y * offsetDistance
  };
}


==== FILE: frontend/src/utils/drawHorseSprite.js ====

// File: frontend/src/utils/drawHorseSprite.js
// Version: v1.6.0 — Adds horse coat color variants based on `horse.variant`

import { Graphics, Texture, Sprite } from 'pixi.js';

const spriteCache = new Map();

/** Variant color map */
const VARIANT_COLORS = {
  bay: {
    body: 0x5c3a1a,
    mane: 0x3a2312,
  },
  chestnut: {
    body: 0xa0522d,
    mane: 0x5c3a1a,
  },
  palomino: {
    body: 0xe6c27a,
    mane: 0xcaa04e,
  },
  black: {
    body: 0x2b2b2b,
    mane: 0x1a1a1a,
  }
};

/**
 * Returns a PIXI.Sprite of a pixel-art horse with Stardew-style silhouette and coat variant.
 * @param {number} colorHex - Saddle color in 0xff0000 format.
 * @param {PIXI.Application} app - The PixiJS application instance.
 * @param {string} variant - One of 'bay', 'chestnut', 'palomino', 'black'
 * @returns {PIXI.Sprite}
 */
export function drawHorseSprite(colorHex, app, variant = 'bay') {
  const key = `${colorHex}_${variant}`;
  if (spriteCache.has(key)) {
    return new Sprite(spriteCache.get(key));
  }

  const gfx = new Graphics();
  const { body: bodyColor, mane: maneColor } = VARIANT_COLORS[variant] || VARIANT_COLORS.bay;
  const eyeColor = 0xffffff;

  // --- Tail (same as mane)
  gfx.beginFill(maneColor);
  gfx.drawRoundedRect(4, 16, 4, 9, 2);
  gfx.endFill();

  // --- Body
  gfx.beginFill(bodyColor);
  gfx.drawRoundedRect(10, 11, 26, 13, 4);
  gfx.endFill();

  // --- Saddle
  gfx.beginFill(colorHex);
  gfx.drawRoundedRect(18, 13, 9, 6, 2);
  gfx.endFill();

  // --- Legs
  gfx.beginFill(bodyColor);
  gfx.drawRect(13, 23, 3, 7);
  gfx.drawRect(17, 23, 3, 7);
  gfx.drawRect(27, 23, 3, 7);
  gfx.drawRect(31, 23, 3, 7);
  gfx.endFill();

  // --- Neck
  gfx.beginFill(bodyColor);
  gfx.drawRect(34, 12, 3, 9);
  gfx.endFill();

  // --- Head (tapered)
  gfx.beginFill(bodyColor);
  gfx.moveTo(37, 12);
  gfx.lineTo(44, 10);
  gfx.lineTo(44, 18);
  gfx.lineTo(37, 16);
  gfx.lineTo(37, 12);
  gfx.endFill();

  // --- Mane
  gfx.beginFill(maneColor);
  gfx.drawRect(37, 9, 2, 2);
  gfx.endFill();

  // --- Eye
  gfx.beginFill(eyeColor);
  gfx.drawRect(42, 12, 1, 1);
  gfx.endFill();

  const texture = app.renderer.generateTexture(gfx);
  spriteCache.set(key, texture);
  return new Sprite(texture);
}


==== FILE: frontend/src/utils/generateHorsePaths.js ====

// File: frontend/src/utils/generateHorsePaths.js
// Version: v3.5.1 — Corrects drift vector logic for all lanes using arc projection
// Date: 2025-05-22

export async function generateHorsePaths({
  horses,
  lanes,
  centerline,
  spriteWidth = 0
}) {
  if (!Array.isArray(horses) || !horses.length) return new Map();
  if (!Array.isArray(lanes) || !lanes.length) return new Map();
  if (!centerline?.getPointAtDistance || typeof centerline.totalArcLength !== 'number') {
    console.error('[KD] ❌ Invalid centerline passed to generateHorsePaths');
    return new Map();
  }

  const DRIFT_LENGTH = 350;
  const horsePaths = new Map();

  horses.forEach((horse, i) => {
    let lane = lanes[i];
    if (!lane || lane.length < 2) {
      console.warn(`[KD] ⚠️ Horse "${horse.name}" skipped - invalid lane path`);
      return;
    }

    const isClosed = lane[0].x === lane.at(-1).x && lane[0].y === lane.at(-1).y;
    if (!isClosed) lane = [...lane, lane[0]];

    const arcPoints = [];
    let arcLength = 0;

    for (let j = 0; j < lane.length; j++) {
      const curr = lane[j];
      const prev = lane[j - 1] || lane[lane.length - 2];
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;
      const segLen = Math.sqrt(dx * dx + dy * dy);
      arcLength += segLen;
      arcPoints.push({ ...curr, arcLength });
    }

    const getPointAtDistance = (distance) => {
      const d = Math.min(distance, arcLength + DRIFT_LENGTH);
      let dist = 0;

      for (let k = 0; k < arcPoints.length - 1; k++) {
        const p0 = arcPoints[k];
        const p1 = arcPoints[k + 1];
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const segLen = Math.sqrt(dx * dx + dy * dy);

        if (dist + segLen >= d) {
          const t = (d - dist) / segLen;
          const x = p0.x + dx * t;
          const y = p0.y + dy * t;
          const rotation = Math.atan2(dy, dx);
          return { x, y, rotation };
        }

        dist += segLen;
      }

      // Project past arcLength using final segment direction
      const pLast = arcPoints.at(-2);
      const pEnd = arcPoints.at(-1);
      const dx = pEnd.x - pLast.x;
      const dy = pEnd.y - pLast.y;
      const remaining = d - arcLength;
      const norm = Math.sqrt(dx * dx + dy * dy) || 1;

      const x = pEnd.x + (dx / norm) * remaining;
      const y = pEnd.y + (dy / norm) * remaining;
      const rotation = Math.atan2(dy, dx);

      return { x, y, rotation };
    };

    const trueFinishDistance = arcLength;
    const driftDistance = arcLength + DRIFT_LENGTH;

    const trueFinish = getPointAtDistance(trueFinishDistance);
    trueFinish.arcLength = trueFinishDistance;

    const driftEnd = getPointAtDistance(driftDistance);
    driftEnd.arcLength = driftDistance;

    horsePaths.set(horse.id, {
      path: lane,
      arcPoints,
      arcLength,
      laneIndex: i,
      driftLength: DRIFT_LENGTH,
      driftEnd,
      trueFinish,
      getPointAtDistance,
      getCurveFactorAt: () => 1.0,
      startDistance: 0
    });

    console.log(`[KD] 🎯 ${horse.name} true finish = ${trueFinishDistance.toFixed(2)} px @ (${trueFinish.x.toFixed(1)}, ${trueFinish.y.toFixed(1)})`);
    console.log(`[KD] 🔴 ${horse.name} drift end = ${driftDistance.toFixed(2)} px @ (${driftEnd.x.toFixed(1)}, ${driftEnd.y.toFixed(1)})`);
  });

  return horsePaths;
}


==== FILE: frontend/src/utils/generateOffsetLane.js ====

// File: frontend/src/utils/generateOffsetLane.js
// Version: v0.6.0 — Finalized 12 o’clock alignment logic with improved logs

/**
 * Offsets a centerline path by a fixed number of pixels using vector normals.
 * Then rotates the path so the closest point to true 12 o’clock becomes index [0].
 * @param {Array<{x: number, y: number}>} centerline - base path
 * @param {number} offset - lane offset in px (+ outward, - inward)
 * @param {{x: number, y: number}} twelveOclockRef - fixed canvas anchor
 * @returns {Array<{x: number, y: number}>}
 */
export function generateOffsetLane(centerline, offset, twelveOclockRef) {
  const offsetPath = [];

  for (let i = 0; i < centerline.length; i++) {
    const p1 = centerline[i];
    const p2 = centerline[(i + 1) % centerline.length];

    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    if (length === 0) continue;

    const normalX = -dy / length;
    const normalY = dx / length;

    offsetPath.push({
      x: p1.x + offset * normalX,
      y: p1.y + offset * normalY
    });
  }

  // 🔁 Rotate path so closest point to 12 o'clock anchor is at index 0
  let bestIdx = 0;
  let bestDist = Infinity;

  for (let i = 0; i < offsetPath.length; i++) {
    const pt = offsetPath[i];
    const dx = pt.x - twelveOclockRef.x;
    const dy = pt.y - twelveOclockRef.y;
    const distSq = dx * dx + dy * dy;
    if (distSq < bestDist) {
      bestDist = distSq;
      bestIdx = i;
    }
  }

  const rotatedPath = [
    ...offsetPath.slice(bestIdx),
    ...offsetPath.slice(0, bestIdx)
  ];

  const delta = Math.sqrt(bestDist);
  console.log(`[KD] ✅ generateOffsetLane(): snapped [0] to 12 o’clock → Δ=${delta.toFixed(2)}px`);

  return rotatedPath;
}

/**
 * Generates all lanes spaced evenly around the centerline and aligned to true 12 o’clock.
 * @param {Array<{x: number, y: number}>} centerline
 * @param {number} laneCount
 * @param {number} laneWidth
 * @param {number} boundaryPadding
 * @param {{x: number, y: number}} twelveOclockRef - fixed visual anchor
 * @returns {Array<Array<{x: number, y: number}>>}
 */
export function generateAllLanes(centerline, laneCount = 4, laneWidth = 30, boundaryPadding = 0, twelveOclockRef) {
  const lanes = [];

  const totalLaneWidth = (laneCount * laneWidth) + (2 * boundaryPadding);
  const halfTrack = totalLaneWidth / 2;

  console.log(`[KD] 🧭 Generating ${laneCount} lanes from centerline`);
  console.log(`[KD] 🧭 Total width: ${totalLaneWidth}px (±${halfTrack}px from center)`);
  console.log(`[KD] 📌 Reference 12 o’clock: (${twelveOclockRef.x.toFixed(1)}, ${twelveOclockRef.y.toFixed(1)})`);

  for (let i = 0; i < laneCount; i++) {
    const offset = -halfTrack + boundaryPadding + (i + 0.5) * laneWidth;
    console.log(`[KD] 🧭 Lane ${i} offset: ${offset.toFixed(1)}px`);
    lanes.push(generateOffsetLane(centerline, offset, twelveOclockRef));
  }

  return lanes;
}


==== FILE: frontend/src/utils/generateTrackPathWithRoundedCorners.js ====

// File: frontend/src/utils/generateTrackPathWithRoundedCorners.js
// Version: v2.5.1 — Starts path at 12 o'clock position

export function generateCenterline({
  canvasWidth,
  canvasHeight,
  trackHeight,
  totalLaneWidth,
  cornerRadius = 100,
  segmentsPerCurve = 12,
  trackPadding = 0
}) {
  const centerX = canvasWidth / 2;
  const centerY = canvasHeight / 2;

  const halfTrack = totalLaneWidth / 2;
  const left = trackPadding + halfTrack;
  const right = canvasWidth - trackPadding - halfTrack;

  const top = centerY - trackHeight / 2;
  const bottom = centerY + trackHeight / 2;

  const r = cornerRadius;
  const rawPoints = [];

  // 🟢 Start at top-center (12 o'clock)
  rawPoints.push({ x: centerX, y: top });

  // 🔵 Top-right curve
  for (let i = 1; i <= segmentsPerCurve; i++) {
    const t = i / segmentsPerCurve;
    const angle = Math.PI * 1.5 + (Math.PI / 2) * t;
    rawPoints.push({
      x: right - r + Math.cos(angle) * r,
      y: top + r + Math.sin(angle) * r
    });
  }

  // 🟣 Bottom-right
  for (let i = 1; i <= segmentsPerCurve; i++) {
    const t = i / segmentsPerCurve;
    const angle = 0 + (Math.PI / 2) * t;
    rawPoints.push({
      x: right - r + Math.cos(angle) * r,
      y: bottom - r + Math.sin(angle) * r
    });
  }

  // 🟠 Bottom-left
  for (let i = 1; i <= segmentsPerCurve; i++) {
    const t = i / segmentsPerCurve;
    const angle = Math.PI / 2 + (Math.PI / 2) * t;
    rawPoints.push({
      x: left + r + Math.cos(angle) * r,
      y: bottom - r + Math.sin(angle) * r
    });
  }

  // 🔴 Top-left
  for (let i = 1; i <= segmentsPerCurve; i++) {
    const t = i / segmentsPerCurve;
    const angle = Math.PI + (Math.PI / 2) * t;
    rawPoints.push({
      x: left + r + Math.cos(angle) * r,
      y: top + r + Math.sin(angle) * r
    });
  }

  // 🔁 Close loop
  rawPoints.push(rawPoints[0]);

  if (rawPoints.length < 2) {
    console.error('[KD] ❌ generateCenterline: Not enough points to compute path');
    return { path: [], totalArcLength: 0, length: 0 };
  }

  // 🧮 Compute arc-length
  const path = [];
  let totalLength = 0;

  for (let i = 0; i < rawPoints.length; i++) {
    const curr = rawPoints[i];
    const prev = i > 0 ? rawPoints[i - 1] : rawPoints[0];
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const segmentLength = Math.sqrt(dx * dx + dy * dy);
    totalLength += segmentLength;

    path.push({
      ...curr,
      arcLength: totalLength
    });
  }

  const getPointAtDistance = (distance) => {
    const dist = distance % totalLength;

    for (let i = 0; i < path.length - 1; i++) {
      const p0 = path[i];
      const p1 = path[i + 1];
      const segLen = p1.arcLength - p0.arcLength;

      if (dist <= p1.arcLength) {
        const t = (dist - p0.arcLength) / segLen;
        const x = p0.x + (p1.x - p0.x) * t;
        const y = p0.y + (p1.y - p0.y) * t;
        const rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
        return { x, y, rotation };
      }
    }

    const last = path.at(-1);
    const preLast = path.at(-2) || last;
    return {
      x: last.x,
      y: last.y,
      rotation: Math.atan2(last.y - preLast.y, last.x - preLast.x)
    };
  };

  console.log(`[KD] 🎯 centerline[0] set to 12 o’clock → (${path[0].x.toFixed(1)}, ${path[0].y.toFixed(1)})`);
  console.log(`[KD] 🔁 Full arc length: ${totalLength.toFixed(2)} px | Points: ${path.length}`);

  return {
    path,
    length: path.length,
    totalArcLength: totalLength,
    getPointAtDistance,
    getCurveFactorAt: () => 1.0
  };
}


==== FILE: frontend/src/utils/parseColorToHex.js ====

// File: frontend/src/utils/parseColorToHex.js
// Version: v1.1.0 — Matches full horse color list from seed.ts

const NAMED_COLORS = {
  red: 0xff0000,
  blue: 0x0000ff,
  green: 0x00ff00,
  yellow: 0xffff00,
  purple: 0x800080,
  orange: 0xffa500,
  pink: 0xff69b4,
  black: 0x000000,
  white: 0xffffff,
  gray: 0x808080,
  teal: 0x008080,
  navy: 0x000080,
  lime: 0x00ff00,
  cyan: 0x00ffff,
  maroon: 0x800000,
  olive: 0x808000,
  beige: 0xf5f5dc,
  indigo: 0x4b0082,
  aqua: 0x00ffff,
  tan: 0xd2b48c,
  charcoal: 0x36454f,
  silver: 0xc0c0c0
};

export default function parseColorToHex(name) {
  if (!name) return 0xaaaaaa;
  const clean = name.trim().toLowerCase();
  return NAMED_COLORS[clean] ?? 0xaaaaaa;
}


==== FILE: frontend/src/utils/playRace.js ====

// File: frontend/src/utils/playRace.js
// Version: v2.10.1 — Adds finish times in seconds to race result logs
// Date: 2025-05-23
// Purpose: Shows accurate race timing in seconds per horse with ordinal labels

import { Graphics } from 'pixi.js';

const DEBUG = true;
const TICK_INTERVAL = 1000 / 30;
const RACE_DURATION_SECONDS = 10;
const FINISH_PROXIMITY_PX = 4;

export function playRace({
  app,
  horseSprites,
  horsePaths,
  labelSprites,
  horses,
  onRaceEnd,
  speedMultiplier = 1
}) {
  const finished = new Set();
  const results = [];
  const distanceMap = new Map();
  const driftJumpMap = new Map();
  const speedMap = new Map();

  const ticksPerRace = RACE_DURATION_SECONDS * (1000 / TICK_INTERVAL);
  const raceStartTime = performance.now();

  horses.forEach((horse) => {
    const { id, name } = horse;
    const path = horsePaths.get(id);
    const driftEnd = path?.driftEnd;
    const trueFinish = path?.trueFinish;

    if (!trueFinish || !path?.getPointAtDistance) {
      console.error(`[KD] ❌ Missing trueFinish or getPointAtDistance for ${name}`);
      return;
    }

    distanceMap.set(id, 0);
    driftJumpMap.set(id, false);

    const normalizedSpeed = (trueFinish.arcLength / ticksPerRace) * speedMultiplier;
    speedMap.set(id, normalizedSpeed);

    if (DEBUG && app?.stage) {
      const blue = new Graphics();
      blue.beginFill(0x0000ff).drawCircle(trueFinish.x, trueFinish.y, 5).endFill();
      app.stage.addChild(blue);

      const red = new Graphics();
      red.lineStyle(2, 0xff0000).drawCircle(driftEnd.x, driftEnd.y, 7);
      app.stage.addChild(red);

      const orange = new Graphics();
      orange.beginFill(0xffaa00, 0.4).drawCircle(trueFinish.x, trueFinish.y, 8).endFill();
      orange.lineStyle(3, 0xff8800)
        .moveTo(trueFinish.x - 10, trueFinish.y - 10)
        .lineTo(trueFinish.x + 10, trueFinish.y + 10)
        .moveTo(trueFinish.x + 10, trueFinish.y - 10)
        .lineTo(trueFinish.x - 10, trueFinish.y + 10);
      app.stage.addChild(orange);

      const driftStart = path.getPointAtDistance(trueFinish.arcLength + 1);
      const purple = new Graphics();
      purple.beginFill(0x800080).drawCircle(driftStart.x, driftStart.y, 5).endFill();
      app.stage.addChild(purple);

      console.log(`[KD] 🎯 ${name} true finish = ${trueFinish.arcLength.toFixed(2)} px @ (${trueFinish.x.toFixed(1)}, ${trueFinish.y.toFixed(1)})`);
      console.log(`[KD] 🟣 ${name} driftStart = (${driftStart.x.toFixed(1)}, ${driftStart.y.toFixed(1)})`);
    }
  });

  const ticker = setInterval(() => {
    horses.forEach((horse) => {
      const { id, name } = horse;
      const path = horsePaths.get(id);
      const sprite = horseSprites.get(id);
      const label = labelSprites.get(id);
      const trueFinish = path?.trueFinish;

      if (!sprite || !label || !path?.getPointAtDistance || !trueFinish) return;

      let distance = distanceMap.get(id);
      const isFinished = finished.has(id);
      const hasJumped = driftJumpMap.get(id);
      const maxDistance = path.driftEnd.arcLength;
      const speed = speedMap.get(id);

      if (isFinished && !hasJumped) {
        distance = trueFinish.arcLength + 1;
        driftJumpMap.set(id, true);
      } else {
        distance = Math.min(distance + speed, maxDistance);
      }

      distanceMap.set(id, distance);

      const point = path.getPointAtDistance(distance);
      let next = path.getPointAtDistance(Math.min(distance + 1, maxDistance));
      if (!point || !next) return;

      sprite.x = point.x;
      sprite.y = point.y;
      sprite.rotation = Math.atan2(next.y - point.y, next.x - point.x);
      label.x = point.x;
      label.y = point.y - 20;

      const dx = point.x - trueFinish.x;
      const dy = point.y - trueFinish.y;
      const pixelDelta = Math.sqrt(dx * dx + dy * dy);
      const justCrossed = !isFinished && pixelDelta <= FINISH_PROXIMITY_PX;

      if (justCrossed) {
        finished.add(id);
        sprite.tint = 0x888888;
        label.style.fill = 0x888888;

        const now = performance.now();
        const elapsed = now - raceStartTime;
        const finishTimeSec = (elapsed / 1000).toFixed(2);

        results.push({ id, name, finalSpeed: speed, finishTimeSec });

        const redDelta = (path.driftEnd.arcLength - trueFinish.arcLength).toFixed(2);

        if (DEBUG) {
          console.log(`[KD] 🏁 ${name} finished ${results.length} at distance ${distance.toFixed(2)} (expected: ${trueFinish.arcLength.toFixed(2)})`);
          console.log(`[KD] 🟧 ${name} actual finish point = (${point.x.toFixed(1)}, ${point.y.toFixed(1)})`);
          console.log(`[KD] 📏 ${name} pixel Δ to blue = ${pixelDelta.toFixed(2)} px`);
          console.log(`[KD] 🧪 Δ to red = ${redDelta} px`);
        }

        if (results.length === horses.length) {
          if (DEBUG) {
            console.log('[KD] ✅ All horses finished — onRaceEnd() triggered');
            results.forEach((r, i) =>
              console.log(`🏁 ${i + 1}${getOrdinal(i + 1)}: ${r.name} — ${r.finishTimeSec} seconds`)
            );
          }
          onRaceEnd(results);
        }
      }
    });
  }, TICK_INTERVAL);
}

function getOrdinal(n) {
  return ['st', 'nd', 'rd'][((n + 90) % 100 - 10) % 10 - 1] || 'th';
}


==== FILE: frontend/src/utils/playReplay.js ====

// File: frontend/src/utils/playReplay.js
// Version: v0.2.0 — Uses arc-distance replays via getPointAtDistance()

export function playReplay({ app, horseSprites, labelSprites, horsePaths, replayData }) {
  if (app.__replayTicker) {
    console.log('[KD] 🔁 Clearing previous replay');
    app.ticker.remove(app.__replayTicker);
    app.__replayTicker = null;
  }

  const startTime = performance.now();
  const horseIds = Object.keys(replayData);
  const framePointers = Object.fromEntries(horseIds.map(id => [id, 0]));

  const ticker = () => {
    const now = performance.now();
    const timeElapsed = now - startTime;

    horseIds.forEach(id => {
      const frames = replayData[id];
      if (!frames || frames.length === 0) return;

      while (
        framePointers[id] < frames.length - 1 &&
        frames[framePointers[id] + 1].time < timeElapsed
      ) {
        framePointers[id]++;
      }

      const curr = frames[framePointers[id]];
      const next = frames[framePointers[id] + 1] || curr;
      const lerpT = (timeElapsed - curr.time) / ((next.time - curr.time) || 1);
      const interpDistance = curr.distance + ((next.distance - curr.distance) * lerpT);

      const path = horsePaths.get(Number(id));
      if (!path || typeof path.getPointAtDistance !== 'function') return;

      const { x, y, rotation } = path.getPointAtDistance(interpDistance);

      const sprite = horseSprites.get(Number(id));
      if (sprite) {
        sprite.position.set(x, y);
        sprite.rotation = rotation;
      }

      const label = labelSprites.get(Number(id));
      if (label) {
        label.position.set(x, y - 20);
      }
    });
  };

  app.ticker.add(ticker);
  app.__replayTicker = ticker;
}


==== FILE: frontend/src/utils/spriteDimensionCache.js ====

// File: frontend/src/utils/spriteDimensionCache.js
// Version: v1.2.0 — Replaces triangle logic with drawHorseSprite, restores getSpriteDimensions()

import { drawHorseSprite } from './drawHorseSprite';

export const spriteDimensionCache = new Map();

/**
 * Measures the width and height of a rendered horse sprite using drawHorseSprite,
 * including variant and saddle color.
 *
 * @param {number} colorHex - Hex color for the saddle.
 * @param {string|number} horseId - Horse ID used for caching.
 * @param {PIXI.Application} appInstance - The current PixiJS application.
 * @param {string} variant - Horse coat variant (e.g. 'bay', 'palomino').
 * @returns {{width: number, height: number}}
 */
export function getSpriteDimensions(colorHex, horseId, appInstance, variant = 'bay') {
  const key = `${colorHex}-${variant}`;
  if (spriteDimensionCache.has(key)) return spriteDimensionCache.get(key);

  const sprite = drawHorseSprite(colorHex, appInstance, variant);
  appInstance?.stage?.addChild?.(sprite);

  const size = {
    width: sprite.width,
    height: sprite.height
  };

  spriteDimensionCache.set(key, size);
  sprite.destroy?.();
  return size;
}


==== FILE: frontend/users.html ====

<!-- File: frontend/users.html -->
<!-- Version: v1.0.3 — Uses Vite-compatible script injection -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lease Loons – Register</title>
    <base href="/users/" />
    <link rel="icon" type="image/png" href="/jll-logo.png" />
  </head>
  <body class="bg-white text-gray-900">
    <div id="root"></div>
    <!-- ✅ Let Vite inject real bundled output -->
    <script type="module" src="./src/main-user.jsx"></script>
  </body>
</html>


==== FILE: frontend/users/index.html ====

<!-- File: frontend/index.html -->
<!-- Version: v1.0.1 — JLL Lease Loons user registration and betting entrypoint -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/jll-logo.svg" type="image/svg+xml" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JLL Lease Loons – Register</title>
    <base href="/users/" />
  </head>
  <body class="bg-white text-gray-900">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


==== FILE: frontend/vite.config.js ====

// File: frontend/vite.config.js
// Version: v0.6.0 — Multi-page config for / and /users
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  server: {
    host: '0.0.0.0',
    port: 5173,
    proxy: {
      '/api': 'http://localhost:4000'
    }
  },
  build: {
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'index.html'),
        users: path.resolve(__dirname, 'users.html')
      }
    },
    outDir: 'dist'
  }
});


==== FILE: nginx/kd.conf ====

# File: nginx/kd.conf
# Version: v0.7.0 — Adds users.html route support for /users SPA

server {
    listen 80;
    server_name kd.paprikacayenne.com;

    root /usr/share/nginx/html;
    index index.html;

    # 🎯 Root SPA fallback to index.html
    location / {
        try_files $uri $uri/ /index.html;
    }

    # 📱 Mobile users SPA fallback to users.html
    location /users {
        try_files $uri /users.html;
    }

    location /users/ {
        try_files $uri /users.html;
    }

    # 🔁 Proxy all /api/ calls to the backend
    location /api/ {
        proxy_pass http://kd_api:4000/;
        proxy_http_version 1.1;

        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 🔌 Proxy WebSocket connections
    location /socket.io/ {
        proxy_pass http://kd_api:4000;
        proxy_http_version 1.1;

        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # 📦 Enable gzip compression
    gzip on;
    gzip_types
        text/plain
        text/css
        application/json
        application/javascript
        text/xml
        application/xml
        application/xml+rss
        text/javascript;
}


==== FILE: package.json ====

{
  "name": "kd-monorepo",
  "version": "1.0.0",
  "private": true,
  "devDependencies": {
    "knip": "^5.58.0",
    "ts-prune": "^0.10.3"
  }
}


==== FILE: package-lock.json ====

{
  "name": "app",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {}
}


==== FILE: scripts/api_rebuild.sh ====

#!/bin/bash

# File: scripts/api_rebuild.sh
# Version: v1.0.0 - Simple rebuild and restart of kd_api service

set -e

# Navigate to the correct project directory
cd /docker/stacks/kd_race_app

# Rebuild the API service
echo "\n🔨 Rebuilding kd_api..."
docker compose build kd_api

# Restart the API service in detached mode
echo "\n🚀 Restarting kd_api..."
docker compose up -d kd_api



==== FILE: scripts/generate_code_snapshot.sh ====

#!/bin/bash

# File: scripts/generate_code_snapshot.sh
# Version: v1.1.0 — Includes Docker, Tailwind, and HTML entrypoints

DATE=$(date +%F)
OUTPUT="scripts/project_snapshot_$DATE.txt"
ROOT=$(cd "$(dirname "$0")/.." && pwd)

echo "📦 Generating full source snapshot for kd_race_app" > "$OUTPUT"
echo "Timestamp: $(date)" >> "$OUTPUT"
echo "Root: $ROOT" >> "$OUTPUT"
echo "==================================================" >> "$OUTPUT"

find "$ROOT" \
  -type f \
  \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.json" \
     -o -name "*.html" -o -name "*.css" -o -name "Dockerfile" -o -name "docker-compose.yml" \
     -o -name "*.conf" -o -name ".env" -o -name "*.sh" \) \
  ! -path "*/node_modules/*" \
  ! -path "$ROOT/volumes/*" \
  ! -path "$ROOT/frontend/dist/*" \
  ! -path "$ROOT/frontend_dist_temp/*" \
  | sort | while read -r file; do
    rel_path="${file#$ROOT/}"
    echo -e "\n\n==== FILE: $rel_path ====\n" >> "$OUTPUT"
    cat "$file" >> "$OUTPUT"
done

echo "✅ Done. Snapshot written to $OUTPUT"


==== FILE: scripts/kd_frontend_builder.sh ====

#!/bin/bash
# File: scripts/kd_frontend_builder.sh
# Version: v0.7.40 – Restores full build and verify flow with volume bind and Nginx check

set -e

clear
echo "♻️  Rebuilding frontend assets..."

# 🔁 Clean temp build directory
rm -rf frontend_dist_temp
mkdir -p frontend_dist_temp

# 🏗️ Step 1: Build the frontend image using Docker multi-stage build
docker build -f frontend/Dockerfile -t kd_frontend_build_temp .

# 📦 Step 2: Extract /app/frontend/dist from the image to temp dir
docker create --name temp_kd_frontend kd_frontend_build_temp
docker cp temp_kd_frontend:/app/frontend/dist/. ./frontend_dist_temp
docker rm temp_kd_frontend

# 📁 Step 3: Copy built files into the volume bind mount used by Nginx
mkdir -p ./volumes/kd_race_app_dist_build
rm -rf ./volumes/kd_race_app_dist_build/*
cp -r ./frontend_dist_temp/* ./volumes/kd_race_app_dist_build/

# 🔄 Step 4: Restart Nginx to reload updated static files
docker compose restart kd_nginx

# ✅ Step 5: Confirm files copied locally
echo -e "\n📦 Final build contents in ./volumes/kd_race_app_dist_build:"
ls -l ./volumes/kd_race_app_dist_build

# 🔍 Step 6: Confirm contents visible inside Nginx container
echo -e "\n🔎 Verifying Nginx container sees build assets:"
docker exec kd_race_app-kd_nginx-1 ls -l /usr/share/nginx/html


==== FILE: scripts/rebuild_all.sh ====

#!/bin/bash
set -e

echo "♻️  Rebuilding frontend assets..."

# Clean temp
rm -rf frontend_dist_temp
mkdir -p frontend_dist_temp

# Build the frontend Docker image from root context
docker build -f frontend/Dockerfile -t kd_frontend_build_temp .

# Create container and extract /app/frontend/dist into temp folder
docker create --name temp_kd_frontend kd_frontend_build_temp
docker cp temp_kd_frontend:/app/frontend/dist/. ./frontend_dist_temp
docker rm temp_kd_frontend

echo -e "\n🔍 Built files in ./frontend_dist_temp:"
ls -l ./frontend_dist_temp

# Ensure Docker volume exists
docker volume create kd_race_app_dist_build >/dev/null 2>&1 || true

# Copy files from temp folder into Docker volume
docker run --rm \
  -v "$(pwd)/frontend_dist_temp:/copy" \
  -v kd_race_app_dist_build:/app \
  alpine sh -c "cp -r /copy/* /app/"

echo -e "\n🚀 Starting backend and Nginx..."
docker compose up -d kd_api kd_nginx

echo -e "\n🧪 Verifying contents in dist volume:"
docker run --rm -v kd_race_app_dist_build:/data alpine ls -l /data

echo -e "\n✅ Deployment complete. Visit: https://kd.paprikacayenne.com/"


==== FILE: .vscode/settings.json ====

{
    "CodeGPT.apiKey": "OpenAI"
}